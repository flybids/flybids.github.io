[{"title":"组件间的通信—派发（dispatch)和广播（broadcast)","date":"2019-07-11T07:56:40.782Z","path":"2019/07/11/组件间的通信—派发（dispatch)和广播（broadcast)/","text":"根据前文，provide/inject的使用具有局限性，对于父子组件的通信必须有其他的办法。 $on 和 $emit在当前vue.js中，较常用的是$on 和 $emit。$emit主要用来触发事件，而$on用来监听被触发的事件。一般来说，子组件中使用$emit，父组件中使用$on。二者具体的用法如下： 1234567891011121314&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt; &lt;slot&gt;确定&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export defalut&#123; methods:&#123; handleClick()&#123; this.$emit(&apos;parent&apos;,&apos;123&apos;) &#125; &#125; &#125;&lt;/script&gt; 123456789101112&lt;template&gt; &lt;i-btn @parent = &apos;test&apos;/&gt;&lt;/template&gt;&lt;script&gt; export default&#123; methods:&#123; test(data)&#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt; dispatch 和 broadcast上述写法一般只能用于一级的父子组件，那么对于多级，在1.x版本的vue.js中使用dispatch 和 broadcast。 dispatch: 子组件向所有的父组件分发，从最近的向远处传播 broadcast: 父组件向子组件广播，从近到远 他们传递的事件一旦被某组件通过$on监听到了，就会停止冒泡下去。可惜的是，在新版本vue.js中已经被废弃。 自主实现dispatch 和 broadcast预计功能：可以向父级组件或子组件，由近到远传播查询，直到找到对应的组件（更据唯一组件name是否一致），然后在改组件中进行监听。 需要传的参数：目标组件名，事件名，事件中用到的参数 具体代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// emmiter.js/** * 父组件向子组件广播事件 * @param cName 目标组件名 * @param eName 事件名 * @param eData 事件参数 */function broadCast(cName,eName,eData)&#123; let children = this.$children children.forEach(ele =&gt; &#123; let name = ele.$options.name if(name === cName)&#123; ele.$emit.apply(ele,[eName].concat([eData])) &#125; else&#123; broadCast.apply(ele,[cName,eName].concat([eData])) &#125; &#125;);&#125;/** * 子组件向父组件分发事件 * @param cName 目标组件名 * @param eName 事件名 * @param eData 事件参数 */function dispatch(cName,eName,eData)&#123; let parent = this.$parent || this.$root let name = parent.$options.name while(parent &amp;&amp; (!name || name!== cName))&#123; parent = parent.$parent if(parent)&#123; name = parent.$options.name &#125; &#125; if(parent)&#123; parent.$emit.apply(ele,[eName].concat([eData])) &#125;&#125;export default&#123; methods:&#123; broadCast(cName,eName,eData)&#123; broadCast.call(this,cName,eName,eData) &#125;, dispatch(cName,eName,eData)&#123; dispatch.call(this,cName,eName,eData) &#125; &#125;&#125; 12345678910111213141516// c-a.vue &lt;tempalte&gt; &lt;button @click=&apos;handleClick&apos;&gt;确认&lt;/button&gt;&lt;/tempalte&gt;&lt;script&gt; import Emmiter from &apos;../mixins/emmiter.js&apos; export default&#123; mixins: [Emmiter] name: &apos;c-a&apos;, methods:&#123; handleClick()&#123; this.broadCast(&apos;c-b&apos;,&apos;test&apos;,&apos;当前组件的数据传给子组件&apos;) &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819// c-b.vue &lt;template&gt; &lt;i-btn @test=&quot;out&quot;/&gt;&lt;/template&gt;&lt;script&gt; import &apos;iBtn&apos; from &apos;../c-a&apos; export default&#123; components:&#123;iBtn&#125;, name:&apos;c-b&apos;, // created()&#123; // this.$on(&apos;test&apos;,this.out) // &#125;, methods:&#123; out(data)&#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"组件间的通信-开始","date":"2019-07-11T07:56:40.782Z","path":"2019/07/11/组件间的通信/","text":"了解一个组件，最基础的三个部分： prop, slot 以及 event。 prop prop定义了该组件有哪些属性是可配置的，对于prop最好使用对象的写法，这样就可以对传入的prop进行校验。 12345678910props:&#123; size:&#123; validator(value)&#123;return test(value)&#125;, default: \"default\" &#125;, page: &#123; type: Number, defalut: 0 &#125;&#125; slot 插槽，主要用来对组件进行扩展，可以是文字，也可以是html或者其他组件。 1234&lt;i-button&gt;按钮 1&lt;/i-button&gt;&lt;i-button&gt; &lt;strong&gt;按钮 2&lt;/strong&gt;&lt;/i-button&gt; 以上是单独一个插槽，也可以使用多个插槽。插槽也可以是命名的插槽。 默认显示内容 1234&lt;i-button&gt; &lt;i-icon slot=\"icon\" type=\"checkmark\"&gt;&lt;/i-icon&gt; 按钮 1&lt;/i-button&gt; event 对于自定义的事件，会使用到$emit, 具体的代码如下： 123456789101112&lt;template&gt; &lt;button @click=&quot;test&quot;&gt;BUTTON&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; methods:&#123; test(event)&#123; this.$emit(&apos;f-click&apos;,event) &#125; &#125; &#125;&lt;/script&gt; 1&lt;i-btn @f-click=\"tan\"/&gt; tips: 对于一些可能和原生事件混淆的自定义事件（如click），可以通过@click.native来区别 接着讲进入本系列的主题——组件间的通信。 组件间的关系可以分为父子关系，兄弟关系。针对父子关系，又可以包含多代父子。组件通信方式多凭借$parent,$children,ref等。 父子组件通信可以通过$parent,$children,但是这只能针对于一代的父子；如果相隔多代，就不可行了。 使用ref的简单例子如下： 12345...&lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;...this.$refs.comA... 所以在实际组件的开发中，我们会考虑使用别的方法。","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"组件间的通信-provide/inject","date":"2019-07-11T07:56:40.782Z","path":"2019/07/11/组件间的通信-projectinject/","text":"在实际开发中，对于比较复杂的组件间的通信，我们一般会引入vux等第三方库。但是在单独开发组件，不考虑引入第三方资源，如开发组件库时，我们可以使用vue内置的provide和inject。 provide相当于主动提供，而inject是依赖注入。 如何理解provide和inject?直接看代码。 12345678910111213141516// 父级组件提供 'foo' 给所有子组件var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;// 子组件注入 'foo'var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125; provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中 他们的局限在于，多用于子组件获取父组件的状态，对于父子组件的通信就不适用。对此，见下文。","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"vuejs组件相关","date":"2019-07-11T07:56:40.781Z","path":"2019/07/11/vuejs组件相关/","text":"基础 组件的data选项必须是个函数，这样每个实例都可以维护被返回对象的独立的拷贝。也就是，使用多个组件时(如组件复用时），彼此不会相互干扰。 12345678// 错误用法data:&#123;count : 0&#125;// 推荐用法data: function()&#123; return &#123; count: 0; &#125;&#125; 通常一个应用会以一颗嵌套的组件树的形式组织。在使用组件时，必须先注册组件，注册组件的方式包括全局注册和局部注册两种。全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。 1234// 全局注册Vue.component(&apos;my-component-name&apos;, &#123; // ... options ...&#125;) props接收父组件传来的数据 123456789// 子组件Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;)// 父组件&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt; 组件必须只能是单个根组件 监听子组件事件，也可以理解为子组件传数据到父组件，和props相反 12345678910// 父组件 接受enlarge-text值，并 +0.1&lt;blog-post ... v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;// 子组件 blog-post发送enlarge-text值&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt; Enlarge text&lt;/button&gt; 插槽的使用 1234567891011121314// 使用组件&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;// 组件Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 效果如下： Error! Something bad happened. 动态组件 有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里，进行tab页的切换效果。 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; currentTabComponent可以包括已注册组件的名字或者一个组件的选项对象。 深入组件组件的注册 注册组件是，需要给组件名 组件名的命名要求语义化，同时小写，推荐xxx-xxx-xxx形式 局部注册组件的使用示例： 1234567import ComponentA from &apos;./ComponentA.vue&apos;export default &#123; components: &#123; ComponentA &#125;, // ...&#125; 对于通用的基础组件，如按钮，输入框等等，可以使用 require.context 只全局注册这些非常通用的基础组件。 1234567891011121314151617181920212223242526272829303132333435363738//在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 获取和目录深度无关的文件名 fileName .split('/') .pop() .replace(/\\.\\w+$/, '') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) Prop Prop的大小写，推荐kebab-case,也可以camelCase 12345Vue.component(&apos;blog-post&apos;, &#123; // 在 JavaScript 中是 camelCase 的 props: [&apos;postTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; props可以参数类型检查 123456789101112131415161718192021222324252627props: &#123; title: String, // 多个可能的类型 likes: [String, Number], isPublished: Boolean, commentIds: Array, // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;,// 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 使用 title=”value”的形式实现传递静态Prop,:title=”value”传递动态Prop。prop可以是数字，布尔值，数组，对象。 单向数据流，从父组件到子组件。如果在子组件中修改prop，会发出警告。 自定义事件 事件名始终使用kebab-case的形式，因为事件名不同于组件和prop，不会自动转换大小写，所以可能无法匹配。 自定义组件的v-model 12345678910111213141516Vue.component(&apos;base-checkbox&apos;, &#123; model: &#123; prop: &apos;checked&apos;, event: &apos;change&apos; &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot; &gt; `&#125;) 1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt; 将原生事件绑定到组件的根元素上，可以使用.native,但是当这个根元素无法触发该事件，如label无法触发focus事件时，此时改绑定事件将失效。 1&lt;test-input v-on:focus.native = &quot;onFocus&quot;&gt;&lt;/test-input&gt; 某些情况下，需要对父组件传给子组件的prop进行双向绑定，此时就需要这样写： 1&lt;text-document :title.sync = &quot;doc.title&quot;&gt;&lt;/text-document&gt; 1this.$emmit(&apos;update:title&apos;,newTitle) 插槽插槽内容 \\123&lt;navigation-link url=&quot;/profile&quot;&gt; 可以是文本，HTML,组件等&lt;/navigation-link&gt; 123456&lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 作用域12345678&lt;navigation-link url=&quot;/profile&quot;&gt; Clicking here will send you to: &#123;&#123; url &#125;&#125; &lt;!-- 这里的 `url` 会是 undefined，因为 &quot;/profile&quot; 是 _传递给_ &lt;navigation-link&gt; 的而不是 在 &lt;navigation-link&gt; 组件*内部*定义的。 --&gt;&lt;/navigation-link&gt; 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 动态组件&amp;异步组件动态组件中使用keep-alive切换组件时，会保持这些组件的状态，避免重复渲染。 1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 处理边界情况访问元素&amp;组件 根实例 this.$root 父级组件实例 this.$parent 子组件实例 1&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; 1this.$refs.usernameInput","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"基础组件开发二三事","date":"2019-07-11T07:56:40.781Z","path":"2019/07/11/组件开发流程/","text":"Keys初始化项目 123vue create my-projectyarn add vue-router // 安装routeryarn add async-validator // 常用的校验库 项目结构调整123456789101112131415++ src++++ assets --静态资源，如图片等++++ components ++++++form ++++++++form.vue++++++++form-item.vue++++++input++++++++input.vue++++ mixins --用来混入++++++emmiter.js --实现dispatch和broadcast++++ views++++++Form.vue++++ main.js++++ App.vue++++ router.js --路由 router.js推荐使用组件按需加载的方式，也就是懒加载，可以节省页面初始化的时间。 1234567891011121314export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/form', name: 'form', component: ()=&gt;import('./views/Form.vue') &#125; ]&#125;) mixin写法1234567import test from '../../test.js' //混入make方法export default&#123; mixins: [test], methods:&#123; this.make() &#125;&#125; 父子组件通信 通过自定义的dispatch和broadcast传递事件 在组件中通过$on监听被触发的事件 组件渲染顺序是从内到外的，子组件的mounted在父组件的mounted之前，在父组件的created之后。所以，应该在父组件的created里面监听事件。 如果只是单纯的传递数据，状态等，可以结合实际，考虑使用provide/inject（可以给所有子组件通过注入的方式使用，类似vux) 和 props(一级一级的传) 常用易混淆的JS方法 filter forEach every every()是对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 some()是对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 filter()是对数组中的每一项运行给定函数，返回该函数会返回true的项所组成的数组。 forEach() 是多数组中的每一项运行给定函数，这个方法没有返回值。它只是对数组中的每一项运行传入的函数，没有返回值。本质上与使用for循环迭代数组一样。 apply call bind call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 立即执行 12func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]); bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 不立即执行，只是创建一个函数 12var boundGetNum = getNum.bind(mymodule);boundGetNum(); AsyncValidator的使用 async-validator异步验证，需要传入验证的规则和需要验证的数据。 1234567// 验证的规则ruleValidate: &#123; name: [ &#123; required: true, message: \"用户名不能为空\", trigger: \"blur\" &#125;, &#123; type:'email', message:'必须为邮箱格式', trigger: \"blur\" &#125; ], &#125; 12345// 需要验证的数据格式&#123; a: xxx, b: xxx&#125; 1234567891011// 验证的通用代码let descriptor = &#123;&#125;;descriptor[this.prop] = rule; // descriptor['name']const validator = new AsyncValidator(descriptor); // 封装验证器let model = &#123;&#125;;model[this.prop] = this.filedValue; // 封装验证的数据validator.validate(model, &#123; firstFields: true &#125;, errors =&gt; &#123; this.validateState = !errors ? 'success' : 'error'; this.validateMessage = errors ? errors[0].message : ''; callback(this.validateMessage); // callback是回调函数&#125;); 调用子组件的方法给子组件一个ref = ‘test’ this.$refs.test.方法()","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"如何更快加载HTML页面","date":"2019-07-11T07:56:40.781Z","path":"2019/07/11/更快加载HTML页面的一些策略/","text":"减少页面的大小排除不必要的空格，注释，内嵌脚本等。 最小化文件数量减少文件引用的数量，也就是降低http请求次数。 减少域名查找每个独立的域名都会耗费DNS查找时间，所以在页面中尽量少的使用来自不同域名的地址 缓存重用的内容确保会被多次使用的内容被缓存，下次加载减少渲染时间 高效排列页面组件页面最初显示时，会先下载页面内容和所需的js以及css。而页面中具有动态特性的资源需要在页面完全加载之后，才会被使用。所以，最好在初始化时关闭动态特性（disable dynamic features ），等页面加载完后再打开它。这样JavaScript就会在网页内容之后才加载，有助于提升页面加载的整体表现。 减少内联脚本使用CSS和合法标志给内容分块指定图像和表格的大小合理选择user-agent尽量使用async和defer1234567891011121314&lt;!--没有 defer 或 async，浏览器会立即加载并执行指定的脚本，不等待后续载入的文档元素，读到就加载并执行 --&gt;&lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;!--加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。--&gt;&lt;script async src=\"script.js\"&gt;&lt;/script&gt;&lt;!--有defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；--&gt;&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt; 更多相关见本链接 页面结构示例HEAD LINK … CSS 文件用来修饰页面外观。在调试维护中把不相关的 CSS 拆分在不同文件中，且尽量减少文件的数量可以提高性能。 SCRIPT … JavaScript 文件用来实现页面加载时的一些功能，但不是所有的 DHTML 在页面加载后才能运行。在调试维护中把不相关的 JavaScript 拆分在不同文件中，且尽量减少文件的数量可以提高性能。· BODY 在一块组件（tables / divs）中用户可见的页面内容，不必等页面完全加载也能显出来的。 SCRIPT … 被用来支持动态页面（DHTML）展示的脚本。 DHTML 脚本通常在页面完全加载或者所有必要的对象（objects）已初始化完毕之后才能运行。没有必要在页面内容之前加载这些脚本，这只会拖慢页面加载和初始化的体验。在调试维护中把不相关的 script 拆分在不同文件中，且尽量减少文件的数量可以提高性能。如有图像用到了反转效果，你应该在页面内容下载完后预加载这些图像。","tags":[{"name":"html","slug":"html","permalink":"https://flybids.github.io/tags/html/"}]},{"title":"变量的解构赋值","date":"2019-07-11T07:56:40.781Z","path":"2019/07/11/变量的解构赋值/","text":"数组解构赋值123456let [a,b,c] = [1,2,3];let [x, , y] = [1, 2, 3];let [head, ...tail] = [1, 2, 3, 4];let [x, y, ...z] = ['a']; // x=a,y=undefined,z=[]let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'let [x, y, z] = new Set(['a', 'b', 'c']); // x='a' 对象解构赋值1234567let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // foo-&gt;aaa,bar-&gt;bbblet &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // baz-&gt;undefinedconst &#123; log &#125; = console;log('hello') // hellolet &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // baz-&gt;foo-&gt;aaa,foo-&gt;undefined 注意点1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 字符串解构赋值123const [a, b, c, d, e] = 'hello'; // a-&gt;'h',...let &#123;length : len&#125; = 'hello'; //len:5 数字和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 函数参数解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 圆括号()问题ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。","tags":[{"name":"js","slug":"js","permalink":"https://flybids.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://flybids.github.io/tags/es6/"}]},{"title":"html相关总结","date":"2019-07-11T07:56:40.780Z","path":"2019/07/11/html相关总结/","text":"常见元素 适配移动端 第一步在head的meta上添加viewwidth=mediawidth form表单 form表单元素提交方式有get和post两种形式，其中对于post，又有encode和formData两种数据格式，后者一般在需要上传文件时使用。 在使用表单元素的时候，可以不用form进行包裹，但是建议使用，原因包括： form表单中可以使用按钮的reset,submit等功能 jQuery等库中有使用到form表单 在一些框架中，使用form可以更好的进行数据校验 有form的时候，用户可以通过浏览器记住密码等。 其他 如何理解HTML 是一个文档 结构 语义化 版本 html5新增元素 语义化 块： section&lt;article nav aside 语义化： header footer form: 新增校验 autofocus em strong i icon 图标 html5的特性 回归html4, 更宽松，更语义化 更多的特性反映在动态特性中，需要结合js才能体现，如本地存储，websocket等等 元素分类 根据样式分类 block inline inline-block 根据内容分类，彼此互相交叉 Flow 可见的 Heading 标题 section 分区 Interactive 可交互动 Phrasing 短语 Metadata 资源 元素嵌套关系 块元素包含行内元素 块元素不一定可以包含块元素 行内元素一般不可以块元素，但是a例外 元素默认样式和定制化 在不同的浏览器中，元素的默认样式可能有所不同，这就需要我们定制化样式。 需要注意的问题 浏览器中读取的是dom，dom是根据html解析获取","tags":[{"name":"html","slug":"html","permalink":"https://flybids.github.io/tags/html/"}]},{"title":"vuejs基础拾遗（一）","date":"2019-07-11T07:56:40.780Z","path":"2019/07/11/vuejs拾遗/","text":"序言在学习并使用vue框架开发了几个项目后，发现自己对vue的一些基本属性和概念有所疏漏。闲暇之余，便重拾vue官网文档，见有不熟悉之处，便摘录余下。以后时有更删。 Vue实例创建实例1new Vue(&#123;&#125;) 数据与方法可以使用Object.freeze()冻结一个对象，使对象的属性无法被修改，但是响应式系统也无法追踪变化。 123let obj = &#123;foo : &apos;bar&apos;&#125;Object.freeze(obj)new Vue(&#123;el:&apos;#app&apos;, data:obj&#125;) 生命周期 生命周期函数不建议使用箭头函数，否则会有this的指向问题 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 模板语法插值 原始HTML,把插值按照HTML进行解析 动态渲染任意HTML比较危险，容易导致xss攻击。只对可信内容使用HTML插值，绝不对用户提供的内容使用插值。 123&lt;p&gt; Using: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 使用v-once指令，一次性插值，当数据更新时，插值处的内容不更新。 1&lt;span v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt; 指令 v-if v-show v-bind 等同于 : 绑定值 v-on 等同于@ 绑定dom事件 计算属性和侦听器计算属性 对于任何复杂逻辑，都应当使用计算属性 12345678910111213141516&lt;p&gt; &#123;&#123; reverseMsg &#125;&#125;&lt;/p&gt;&lt;script&gt;var vm = new Vue(&#123;el:&apos;#example&apos;,data:&#123;msg: &apos;Hello&apos;&#125;,computed:&#123;reverseMsg: function()&#123;return this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125;&#125;)&lt;/script&gt; vs methods computed中的方法动态绑定相关的值，如上述的msg.当msg变化时，会重新执行渲染。同时，只要msg没有变化，即便多次使用reverseMsg也不会重复执行多次reverseMsg，相当于缓存。 vs watch 可以使用computed的话，就不要使用watch.使用watch可能代码重复等。 setter 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 侦听器当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 watch 选项之外，您还可以使用命令式的 vm.$watch API。 Class与Style绑定绑定HTML Class 对象语法 12345678910111213141516171819&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;script&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .active&#123;&#125; .text-danger&#123;&#125;&lt;/style&gt; 数组语法 12345&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 渲染为： 1&lt;div class=\"active text-danger\"/&gt; 用在组件上 当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 绑定内联样式 对象语法 1234567&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125;&lt;/script&gt; 更推荐： 1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 数组语法 将多个样式对象应用到同一个元素上 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 自动添加前缀 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值 v2.3.0+ 为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值。 1&lt;div :style=&quot;&#123; display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] &#125;&quot;&gt;&lt;/div&gt; 在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 条件渲染v-if vs v-show v-if v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 如何选择 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 不推荐同时使用 v-if v-forv-for 具有比 v-if 更高的优先级 列表渲染v-for v-for = “item in items” v-for = “item of items” 可以遍历对象和数组，在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 对象更改检测注意事项由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除。 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。 1Vue.set(vm.userProfile, &apos;age&apos;, 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名。 1vm.$set(vm.userProfile, &apos;age&apos;, 27) 过滤和排序有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法。 一段取值范围v-for 也可以取整数。在这种情况下，它将重复多次模板。 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 渲染为： 11 2 3 4 5 6 7 8 9 10 v-for on a \\类似于 v-if，你也可以利用带有 v-for 的 &lt;template&gt; 渲染多个元素。 123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"vuejs运用机制概览","date":"2019-07-11T07:56:40.780Z","path":"2019/07/11/vue-源码学习总结(一)/","text":"序言在断断续续做过一段时间的vue项目之后，不久又掘金上看到的vue学习小册，简单浏览一遍，受益良多。所以简单的通过摘录，笔记的形式，边学习便记忆，加深自己对vue原理的理解，并帮助自己日后进一步的研究vue的源码。 总览vue 初始化和加载 在 new Vue() 之后，会调用 vue._init() 函数进行初始化，包括生成生命周期，事件，props, data, methods, computed, watch 等等。 最主要的是通过Object.defineProperty设置setter和getter函数，实现响应式和依赖采集； 初始化之后，通过$mount 挂载组件，存在template时，需要进行编译。 编译 parse阶段 借助正则表达式解析template中的css,class,style,指令等，生成AST optimize阶段 标记静态节点，这样以后update页面需要通过patch来比较渲染dom的时候，会跳过静态节点，从而减少比较的时间，提升patch的性能，对编译过程实现优化。 generate阶段 将AST转换为render function字符串等。 经过以上三个阶段之后，组件中就会存在渲染VNode节点需要的函数。 响应式 在初始化阶段，我们设置了getter和setter方法，分别在读取和赋值的时候触发。 渲染组件的时候，会进行读取操作，触发getter函数，实现依赖收集，将观察者watcher收集放入当前闭包的订阅者Dep里面； 对组件进行修改时，会触发setter函数，setter会通知之前收集的所有观察者，让他们重新渲染视图。在渲染过程中，有用到update和patch等。 Virtual DOMrender function 生成 vNode 节点，这些节点组成 vDom(js对真实DOM的抽象) 更新视图","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"let 和 const","date":"2019-07-11T07:56:40.780Z","path":"2019/07/11/let-和-const/","text":"let 命令基本用法let 变量的作用域是在其对应的代码块，var 的变量是全局变量，会挂载在顶层变量上。 对于for循环，设置循环变量的作用域是父作用域，循环体内部是单独的子作用域。同名变量在子作用域会覆盖父作用域传来的值,但是在父作用域对应变量值不受影响。具体如下： 1234567for(let i =0;i&lt;3;i++)&#123; let i ='abc' console.log(i)&#125;//abc//abc//abc 变量提升对于用let和const声明的变量不会发生变量提升，而使用var会发生变量提升。所以，var变量在声明前使用不报错，而let和const会报错。 变量提升：js从上到下执行时，分为词法分析和执行两个阶段。在词法分析阶段，包括分析形参，分析变量，分析函数声明三个部分。经过词法分析后，会将存在的变量声明和函数声明，进行一番处理，比如赋值等。具体代码如下： 12console.log(a)var a =12 词法分析后的代码为： 123var a = undefinedconsole.log(a)a=12 运行的结果是： 1undefined 暂时性死去TDZ由于let/const不会变量提升，在作用域内，变量声明之前的部分，对于该变量都属于死区，也就是暂时性死区。 TDZ导致typeof运算符不再安全，当在变量X的暂时性死区中使用typeof检验X时，此时会抛出ReferenceError。 不允许重复声明块级作用域使用{ 和 } 包裹的作用域 let &amp; constconst声明只读变量，必须赋值，一旦声明就不能改变它的值。但是如果声明的是个对象时，可以改变对象的属性值。本质上，不可改变的是指针指向的对象，或者说内存地址所保存的数据不得改动。对于字符串，数字等简单变量，内存地址保存的就是它的值，但是对于对象，数组等保存的是指向数据的地指针。 const变量的作用域只在声明的块作用域有效，没有变量提升，有TDZ. 冻结对象12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 123456789// 将对象本身冻结，对象的属性也冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 声明变量6种方式 var function let const class import","tags":[{"name":"js","slug":"js","permalink":"https://flybids.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://flybids.github.io/tags/es6/"}]},{"title":"git 进阶","date":"2019-07-11T07:56:40.779Z","path":"2019/07/11/git-进阶/","text":"head master 和 branchhead:当前commit的引用当前commit指的是当前工作目录对应的commit branch：分支如果我在这时创建一个 commit，那么 HEAD 会带着 master分支 一起移动到最新的 commit master是默认的分支,git clone时会自动checkout到master 分支的创建 切换 删除12345678910## 创建分支git branch branch1## 切换分支git checkout branch1## 合并以上两条命令，创建并切换分支git checkout -b branch1## 删除分支,没有合并到主分支上的分支(分支上的内容已经被追踪或者已经被commit)删除会失败git branch -d branch1## 确认删除,不考虑有没有mergegit branch -D branch1 push的本质 push是上传当前的分支，并上传当前分支的所有commit push时，如果当前分支是本地新创建的一个分支，需要指定远程仓库名和分支名 1git push origin branch1 push的时候之后上传当前分支，并不会上传HEAD；远程仓库的HEAD是永远指向默认分支（即master)的。 merge合并commits指定一个commit,合并到当前commit 123## 当前分支是A,需要合并的分支是Bgit merge B## 此时，B被合并到A上面 merge应用场景 一个分支开发完毕，需要合并到原来的分支 pull的内部操作 特殊情况 冲突 一个分支修改A文件，另一个分支修改B文件，合并时自动完成 一个分支修改A文件的第100行，另一个分支修改A文件的第20行，合并时自动完成 当修改同一文件的同一位置，无法自动完成，会出现冲突。 解决冲突 手动合并 add =&gt; commit 如果放弃解决冲突，可以取消merge,回到merge前的状态 1git merge --abort head领先于当前commit 此时，merge时的commit与Head处的commit之前不存在分叉，没有什么需要合并的，所以不会进行合并，是一个空操作。 head落后于当前commit 如果 HEAD 和目标 commit 依然是不存在分叉，但 HEAD 不是领先于目标 commit，而是落后于目标 commit, Git 会直接把 HEAD（以及它所指向的 branch，如果有的话）移动到目标 commit。快速前移fast-forward 最流行的团队开发的工作流：Feature Branching这种工作流的核心包含以下两点： 任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； branch 写完后，合并到 master，然后删掉这个 branch。 命令行流程 1234567891011121314## 创建工作分支git checkout books## 分支代码完成后git push origin books## 同事review代码，合格后,mergegit checkout mastergit pullgit merge books## push代码git push## 删除工作分支git branch -d books## 如果有远程分支，也删除git push origin -d books 关于addadd把改动的内容放入暂存区 123## 全部暂存git add .## 每次修改或新增后需要重新add 看看我都干了些什么1234567891011121314## 了解修改时间，修改人，修改动作git log## 还需要看到修改细节git log -p## 查看修改统计git log --stat## 查看当前commit的内容git show## 比较暂存区和上一次提交git diff --staged## 比较工作目录和暂存区git diff## 比较工作目录和上一次提交git diff HEAD","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"git 高阶","date":"2019-07-11T07:56:40.779Z","path":"2019/07/11/git-高阶/","text":"rebase和merge使用merge会使commit的历史中出现分叉，这种分叉再汇合的结构显得混乱，难以管理。此时就需要用到rebase变基。 rebase: 把你指定的 commit 以及它所在的 commit 串，以指定的目标 commit 为基础，依次重新提交一次。 动态示意图： merge 1git merge branch1 rebase 12git checkout branch1git rebase master 另外，在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit： 12git checkout mastergit merge branch1 A—B—C topic / D—E—F—G master &gt;==git rebase master ==&gt; A’–B’–C’ topic / D—E—F—G master 应用场景： 我在主分支commit a时新建了新分支，此时开始分叉，分叉后我又在主分支改了东西commit b，此时我后悔了，我不该在commit a时分叉的，因为commit b的东西我新分支也需要，此时用衍合，就等于我丢弃原分叉，在commit b重新分叉（原分叉的改动内容当然也是带上的，没有丢） commit时提交的文件存在错误1234## 修正文件git add 1.text## 重新commit，当前commit会替换掉之前的commitgit commit --amend 取消当前的commit12git reset --hard HEAD^## 撤销的提交并没有消失，只是失效了 取消之前的commit123git rebase --onto HEAD^^ HEAD^ branch1## 以倒数第二个 commit 为起点（起点不包含在 rebase 序列里哟），branch1 为终点，## rebase 到倒数第三个 commit 上。 1234## 在编辑界面中删除想撤销的 commitsgit rebase -i 哪一个commit## 在 rebase 命令中直接剔除想撤销的 commitsgit rebase --onto 哪一个commit 错误的代码push到中央仓库了错误代码还在自己的分支上修改或删除错误的commit,然后push 如果本地在上次commit之后有了修改，再push会失败，可以强行push 1git push origin branch1 -f 错误代码已经合并到master123## 撤销错误的提交（相当于增加相反的commit，覆盖之前的commit）git revert HEAD^## 然后push reset用途reset命令的本质：重置HEAD和他所指向的branch的位置 更具参数的不同，有不同的用途： –hard：重置位置的同时，清空工作目录的所有改动； –soft：重置位置的同时，保留工作目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区。 –mixed（默认）：重置位置的同时，保留工作目录的内容，并清空暂存区。 checkout 本质checkout不仅可以用来切换分支，其本质是签出指定的commit 123git checkout branch1git checkout HEAD^git checkout master~5 checkout只带着head走，reset带着head和branch一起走 stash临时需要切换分支，当前分支的改动不想提交，但是需要暂存起来，之后切换回来时可以再取出来 没有没跟踪(tack)过的（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们），需要先add,然后stash 1234## 存git stash## 取git stash pop 恢复删除的branch123456## 查看历史git reflog## 假设HEAD 的最后一次移动行为是「从 branch1 移动到 master」。而在这之后，branch1 就被删除了。## 所以它之前的那个 commit 就是 branch1 被删除之前的位置了，也就是第二行的 c08de9a。git checkout c08de9agit checkout -b branch1","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"git深入学习之VCS","date":"2019-07-11T07:56:40.779Z","path":"2019/07/11/git深入学习之VCS/","text":"什么是版本控制系统VCS最基本功能：版本控制保留对文件的修改历史，方便撤销更改和回退到指定版本 主动提交多人合作的同步需求：中央仓库所有人的改动都推送到中央仓库，所有人都可以从中央仓库看到和下载别人的改动 两种版本控制系统中央式版本控制系统 CVCS工作模型A,B,C三人共同参与一个项目的开发，假设有一个中央仓库O,BC从O中同步获取A的代码，然后三人开始同步开发。每次有人提交代码到O时，另外两人可以将这些最新代码从O同步到本地。 中央仓库功能 保存版本历史 同步团队代码 分布式版本控制系统 DVCSDVCS和CVCS的区别是，除了有一个共同的中央仓库意外，本地也有一个仓库，记录了所有的本地版本历史。 中央仓库功能保存版本历史的功能转给本地仓库，中央仓库的功能更多的偏向于同步团队代码。 工作模型 主工程师在本地仓库提交代码 搭建中央仓库，把本地仓库代码推送到中央仓库 其他成员从中央仓库同步代码到本地仓库，开始并行开发 成员将本地的每一个需要提交的改动提交到本地仓库 完整的功能开发完毕后，再将代码从本地仓库推送到中央仓库 每次有人推送代码时，其他人可以将最新代码同步到本地仓库 优点和确点优点 多数操作可以本地进行，不受工作环境网络限制 由于可以本地提交，可以分步提交代码，把代码提交做的更详细，方便review 缺点 初次获取项目clone耗时长 每个机器都有本地仓库，占内存比较大","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"Hello World","date":"2019-07-11T07:56:40.779Z","path":"2019/07/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"CSS查漏补缺（二）","date":"2019-07-11T07:56:40.778Z","path":"2019/07/11/CSS查漏补缺（二）/","text":"CSS效果 效果属性 box-shadow 12box-shadow: 6px 6px 10px 10px rgba(1,2,3,4) 偏移量x,y+模糊区域z+扩展l+颜色c 外阴影box-shadow: inset x y z l color; 内阴影 阴影不会占位置，也就是不影响其他元素的布局。box-shadow后面可以跟多组值，从而有多个阴影。 营造立体感，层次感 充当没有宽度的边框 做一些特殊效果，如机器猫等 test-shadow text-shadow的值可以有多组，类似box-shadow 123.text&#123; text-shadow:1px 1px 1px #ddd; // 右下角(1,1) 模糊（1） 颜色（#ddd)&#125; 立体感 印刷的感觉 border-radius 圆角=》圆角矩形，原先，扇形，其他的图案 123456789.test&#123; border-radius:20%; // 值可以是百分数，具体的像素&#125;。test2&#123; border-top-left-radius:100px;&#125;.test3&#123; border-radius: 10px 10px 10px 10px / 20px 20px 20px 20px; // 水平和垂直方向&#125; background 纹理 图案 渐变 雪碧图动画 背景图尺寸适应 123background-position : center top;background-size: 200px 100px; // 或者百分比 或者cover 或者containbackground-repeat: repeat-x; clip-path 对容器显示进行裁剪，不影响占位 常见的几何图形 自定义路径进行裁剪 兼容性不好 123456789.div&#123; clip-path: inset(100px 50px) 方形 居中保留 // （100,100）的r =50 圆 cliP-path: circle(50px at 100px 100px) //多边形几个重要的节点连接 clip-path: polygon(50% 0,100% 50%,50% 100%, 0% 50%) // 使用svg clip-path:url(#clipath)&#125; 3D/2D 变换 ,不是动画 translate 位移 scale 缩放 skew 斜切 斜着拉扯 rotate 旋转 问题 一个div画出叮当猫： box-shadow无限投影+::before+::after 不占空间的边框 box-shadow outline 定制性不高 实现圆形 圆角矩形等 border-raius 实现ios图标的圆角 clip-path:(对应svg) 实现3d效果 123perspective: 500px; 透视角度transform-style: preserve-3d; 保留3d效果transform: translate rotate ...... CSS动画 动画给人以愉悦舒适的感觉，可以用来引起注意，对我们的操作进行反馈 questions css动画性能 性能不坏 部分情况下优于js js可以做到更好 部分属性兼容性差，如box-shadow 过渡动画和关键帧动画区别 过渡动画有状态变化 关键帧动画不需要状态变化 关键帧动画控制更精细 动画类型： transition补间动画 keyframe关键帧动画 逐帧动画（帧数从少到多） 补间动画 位置-平移 left/right/margin/transform 方位-旋转 transform 大小-缩放 transform 透明度 opacity 其他-线性变换(如宽度 高度等) transform 12transition : width 21s，height background 2s; //全部 all 10stransition-timing-function: linear // 动画进度和时间的关系,值有很多，也可以用贝塞尔曲线 关键帧动画 相当于多个补间动画，与元素状态的变化无关，定义更加灵活 123456789101112131415.test&#123; animation:run 1s; 或者 run 1s linear; animation-direction: reverse; // 反向 animation-iteration-count: infinite; // 次数，无限 animation-play-state: paused; //暂停 animation-fill-mode: forwards; //来回变&#125;@keyframes run&#123; 0%&#123; width :100px; &#125; 100%&#123; width: 1000px; &#125;&#125; 逐帧动画 没有自动补充帧的动画，关键帧动画的特殊用法之一（无法补帧,如多张图片在短时间内连续变换） 适用于无法补间计算的动画，资源较大，使用steps()，动画面积小，时间短 123456.test&#123; animation: run 1s linear; animation-iteration-count:infinite; animation-timing-function:steps(1); 关键帧之间有几个画面&#125;@keyframes run&#123;&#125; 预处理器基于css的另一种语言。可以借助工具编译成css,添加了很多css不具备的特性。它可以提升css文件的组织，如实现模块化等。主要包括两种，less , scss或者sass. less: 基于nodejs，编译快 scss: 基于ruby,编译慢 介绍 嵌套 反应层级和约束 变量 计算 减少重复代码 Extend Mixin 代码片段 循环 适用于复杂有规律的样式 import CSS文件模块化 嵌套 less 12345678910111213.wrapper&#123; background: red; .nav&#123; font-size:12px; &#125; .content&#123; font-size:21px; &amp;:hover&#123; // 平级 color: gray; &#125; &#125;&#125; scss 123456789101112.wraper&#123; background: white; .nav&#123; font-size:12px; &#125; .contend&#123; font-size:21px; &amp;hover&#123; backgroud: red; &#125; &#125;&#125; 变量 计算 减少重复代码 less 123456@fontSize: 12px;@bgColor: gray;.nav&#123; font-size: @fontSize + 10px; background: lighten(@bgColor, 40%)&#125; scss 123456$fontSize: 12px;$bgColor: gray;.nav&#123; font-size: $fontSize + 10px; background: lighten($bgColor,40%)&#125; mixin 对于共同代码，编译的css中是直接复制，重复率高，体积相对偏大 scss 123456789$fontSize: 12px;$bgColor: gray;@mixin block($fontSize)&#123; font-size: $fontSize; color: red;&#125;.nav&#123; @inclue block($fontSize+10px)&#125; less 123456789101112131415@fontSize: 12px;@bgColor: gray;.block(@fontSize,@bgColor)&#123; // 需要复用的代码 font-size: @fontSize + 10px; border: 10px solid red; background: lighten(@bgColor, 40%)&#125;.box&#123; color: blue;&#125;.nav&#123; .block(@fontSize+2px,@bgColor); .color();&#125; extend 编译的结果更小 less 123456789101112@fontSize: 12px;.block&#123; font-size:@fontSize; color: red;&#125;.wraper&#123; .nav:extend(.block)&#123; &amp;:hover&#123; color:yellow &#125; &#125;&#125; scss 1234567891011$fontSize: 12px;.block&#123; font-size:$fontSize; color: red;&#125;.box&#123; .nav&#123; @extend .block; &amp;:hover&#123; color: red; &#125; &#125;&#125; loop less 不支持循环，所以使用递归的方式实现 1234567.gen-col(@n) when (@n&gt;0) &#123; .gen-col(@n - 1); .col-@&#123;n&#125;&#123; width:1000px/12*@n; &#125;&#125;.gen-col(12); scss 支持循环 12345678910111213141516@mixin gen-col($n)&#123; @if $n&gt;0&#123; @include gen-col($n-1); .col-#&#123;$n&#125;&#123; width: 1000px/12*$n; &#125; &#125;&#125;@include gen-col(12) // 简单写法 @for $i from 1 through 12&#123; .col-#&#123;$i&#125;&#123; width: 1000px/12*$i; &#125;&#125; import less 12@import \"./1-import-variabel\"; //1@import \"./2-import-variable\"; //2 12// 1 定义变量的文件@fontSize: 20px; 123456// 2 模块文件.mdel&#123; .box&#123; font-size:@fontSize + 20px; &#125;&#125; scss 类似less 12@import \"./1-variabel\" @import \"./2-mdelss\" CSS预处理框架 SASS-Compass 处理兼容性等 Less-Lesshat/EST 12345@import \"est/all\" // 按需编译，用到的才会引入编译 .left&#123; float:left; .clearfix();&#125; 提供现成的mixin,类似JS类库 封装常用功能 其他","tags":[{"name":"css","slug":"css","permalink":"https://flybids.github.io/tags/css/"}]},{"title":"CSS查漏补缺（一）","date":"2019-07-11T07:56:40.777Z","path":"2019/07/11/CSS查漏补缺/","text":"CSS样式叠加问题 选择器的分类和权重计算 权重计算 ID选择器 +100 类 属性 伪类 +10 元素 伪元素 +1 其他 +0 需要注意的是，计算的时候不进位，权重低的不能通过数量来战胜权重高的 ！important最高 元素属性的优先级高 相同权重 后面写的会覆盖前面写的 分类： 类选择器.name{}， 元素选择器a{}， 伪元素选择器::before{}, 真实存在的元素,老旧的IE用单冒号 属性选择器[type=radio]{} 伪类选择器 :hover{} 某种状态下 ID选择器 组合选择器[type=checkbox]+label{} 否定选择器 :not(.link){} 通用选择器 *{} 浏览器对css的解析方式是从右到左，反过来的；这是出于对性能的考虑，更快的找到元素。 非布局样式 字相关 多字体 fallback,一个字体找不到，用下一个字体,针对的是每一个字符 使用网络字体， 自定义字体 (用于字体图标，宣传品牌banner等固定文案) 123456789@font-face&#123; font-family:\"IF\", src: url(\"地址\") // 可以本地，也可以远程&#125;.test&#123; font-family:IF;&#125;// 使用远程字体时，需要对应远程字体运行跨域// 远程也可以先用link引入，然后直接使用 iconfont 可以参考阿里矢量库 字体族：一堆的字体；不能加引号 衬线字体 宋体等 serif 非衬线字体 笔画起收规则的，如黑体 sans-serif 等宽字体 每个字符宽度相同 monospace 非等宽字体 手写体 cursive 花体 fantasy 1234.name&#123; font-family:\"PingFang SC\",serif;&#125;// serif 是字体族 PingFang SC是字体名称 背景和边框 边框 属性：线型 大小(solid dashed dotted) 颜色 1border: 1px solid blue; 边框背景图 12border: 30px solid transprant;border-image:url('../test.png') 30 round // 不常用 边框衔接 三角形 斜切 12border-bottom:30px solid red;border-right:30px solid blue; 背景 背景颜色 123456789101112test1&#123; background: red; // 少用&#125;test2&#123; background:rgb(1,2,3) // 不适合人眼，rgba透明度&#125;test3&#123; background:hsl(0,100%,50%) // 颜色 饱和度 亮度，适合人眼 hsla透明度&#125;test4&#123; background:url('../img/1.png')&#125; 渐变色背景css3,渐变可以当做图片背景，可以使用background-size属性等 1234567891011121314.c1&#123; background:linear-gradient(to right,red,green) // 左到右&#125;.c2&#123; background:linear-gradient(0deg,red,green) // 下到上， 45左下角到右下角&#125;.c3&#123; // 左到右,可以多个颜色 background:linear-gradient(to right,red 0,green 10%,yellow 100%) &#125;.c4&#123; // 叠加 background:linear-gradient(135deg,transparent 0,transparent 45%, red 45%, transparent 100%)，linear-gradient(135deg,transparent 0,transparent 45%, red 45%, transparent 100%)&#125; 多背景叠加css3 背景图片和属性 雪碧图 性能优化,减少http请求数，提高加载性能 123456&#123; background:red url('../q.png') // 图片平铺，改在颜色上面 // background-repeat(no-repeat,repeat-x等值） // background-position(center,top,20px等) , 坐标位置（相对于容器，取反数，一般负数） // background-size 缩小放大等等，缩小可以用来适配移动端好分辨率，比如分辨率三倍，就图片像素增加三倍，size缩小三倍&#125; base64 和性能优化 减少了http的请求 将图片转换为base64文本，使用javascript或工具进行转换；增大了解码的开销，体积增大三分之一，所以一般用于小图标，小图片。 项目中使用base64的时候，在打包的时候把图片转成base64 多分辨率适配 滚动 换行 文字折行 overflow-wrap 兼容性不好，一般写word-wrap，通用换行（是否保留单词） word-break 针对多字节文字（中文橘子也是单词） white-space 空白处是否换行 123456&#123; word-break: normal; // break-word 对单词可以换行 break-all 所有单词都可以换行 keep-all 所有单词都保留完整 overflow-wrap:normal; white-space:normal;&#125; 滚动： 内容比容器多 滚动行为 滚动条 (visible超出可见 hidden超出隐藏 scroll有滚动条 auto看情况滚动条) 1overflow:hidden; // 默认auto 粗体 斜体 下划线 这都是些装饰性属性。 font-weight:lighter normal=400 bold=700 bolder 100 (100到900，取x00,有兼容性)，一般normal或者bold, lighter bolder不同浏览器设备显示有差别 font-style: itatic 斜体 text-decoration cursor 其他 行高 line-height 行高的构成: 一行的最大行高可以撑起外层盒子的高度（line-box包含inline-box)，可以基于这个实现垂直居中。 行高相关的现象和方案： 行内元素默认baseline对齐；在设置对齐方式时，每个行内元素都要设置vertical-align,vertical-align也可以使用数字（此时是相对于baseline的位置）； 布局 layout 简介 早期以table为主，但是用户等待时间更长，语义不明确；后期以技巧性地布局为主（本来不是用来布局的东西） 现在有flexbox， grid, 响应式布局 常见布局方法： table, float+margin, inline-block,flexbox 盒模型 content padding border margin (height,width指content) display(block,inline,inline-block) position(static, absolute脱离文档流,fixed脱离文档流,relative,sticky新的属性,还有inherit) z-index只对定位元素有效，什么是定位元素呢？说简单点就是设置了position属性的元素，position的属性值如下：absolute-绝对定位、relative-相对定位、fixed-固定定位、inherit-继承父元素定位，static-静态定位。这里要注意，并不是所有的定位设置都有效果，absolute、relative和fixed是肯定有效果的，inherit取决于父元素，如果父元素没有设置定位则z-index无效，注意低版本IE浏览器不支持这个值。最后说下static这个静态定位，其实这是默认值，表示当前元素不进行定位，所以如果元素设置了这个属性值，其实是和没有设置是一样的，会使元素忽略掉z-index属性，使其不起作用。 盒模型 content padding border margin (height,width指content) flexbox 弹性盒子 盒子本来就是并列的，指定宽度就可 12345678910.item0&#123; flex:1; 占据box的一份 &#125;.itm1&#123; flex: none; width:70px; 占70px宽带&#125;.box&#123; display:flex;&#125; flexbox还有其他的属性,由于兼容性的问题，还没有被大规模使用，移动端兼容性更好 float布局 元素浮动，脱离文档流（不对其他元素布局起作用），但是不脱离文本流（会排挤其他元素的文本） 形成块（BFC),宽和高自己定，位置尽量（上，左（右）） 相当于从父级消失，可能导致父级的高度塌陷 可以使用伪元素清楚浮动 1234567cls::after&#123; display:block; content:''; visibity: hidden; height:0; clear:both;&#125; 问题：float + margin 三栏布局 inline-block 布局 像文本一样排block元素，但是需要处理间隙问题 解决间隙问题：父元素字体大小设为0，里面的字体再设回来；或者再代码里面，两个inline-block之间没有空格，或者加上注释占用空格 1234567891011test1&#123; font-size :0; .child1&#123; font-size:14px; display:inline-block; &#125; .child2&#123; font-size:13px; display:inline-block; &#125;&#125; 12345&lt;div style=\"display:inline-block;\"&gt; 123&lt;/div&gt;&lt;div style=\"display:inline-block\"&gt; 456&lt;/div&gt; 响应式布局 再不同设备上正常使用，一般针对屏幕大小。主要的方法包括： 隐藏一些东西 + 折行 + 留下自适应空间 rem, viewport , media query 1234567891011&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;...&lt;meta name=\"viewport\" content=\"width=320\"&gt;....&lt;style&gt; @media (max-width:640px)&#123; .left&#123; display:none; &#125; &#125;&lt;/style&gt; 12 table 布局 直接用表格 仿照表格的样式 12display: table-cell;display: table-row; CSS Hack 兼容浏览器，不合法但是生效的写法，难理解，难维护，容易失效，hack属性要写在正常属性后面 1234.test&#123; width:200px; width:100px\\9;&#125; 替代方案：特性检测，针对性加class,更推荐 如何优化checkbox label[for] 和 id 隐藏元素input :checked + label 12","tags":[{"name":"css","slug":"css","permalink":"https://flybids.github.io/tags/css/"}]}]