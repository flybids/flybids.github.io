[{"title":"千面英雄——从神话中认识英雄之路","date":"2020-08-02T10:41:43.392Z","path":"2020/08/02/千面英雄——解读神话的英雄之路/","text":"书籍简介书名由来：通过对大量东、西方神话的比较研究，从中总结出一个英雄的原型，这本书也因此而得名。“千面英雄”，意指神话中的英雄只有一个，那些不同时代、不同民族的神话中的英雄尽管千姿百态、各不相同，实际上乃是同一个英雄被不同的文化赋予千差万别的面貌而已。 两个主题：神话的统一模式（英雄之路）； 宇宙真理（如各种版本的创世神话，复活升天等） 神话学大师约瑟夫·坎贝尔的奠基之作 整合了全球各地的童话、民间传说以及神话故事，并从中提炼出英雄之路的原型 寻求个人内在觉醒的“圣经”，探索自我与灵性成长的必读之作 英雄之路作者指的英雄是什么英雄是我们每个人内心都隐藏着的神性，只是等待着我们去认识和呈现出来。 认识英雄之路的意义为了成为英雄，我们要像神话中的英雄一样，接受冒险的召唤，跨越阈限、获得援助、仅受考验、被传授奥义，最终回归。我们都是自己的英雄，每个人都需要理解并经历自己的英雄故事。比如： 启程:离开母亲子宫，来到现实世界；启蒙:家庭教育和学校教育；考验:工作不顺，生活艰辛；回归:退休回家。 启程:离开平静生活，开始努力做事；启蒙:找到榜样，不断学习进步；考验:遇到困难和挫折；回归:完成事情，回到平静生活。 英雄之路的普适性真理只有一个，而圣人用各种不同的名字称呼它。无论是从古老神话传说，还是现当代的小说电影都可以看到英雄之路的原型。 代表人物 释加牟尼 盗火者普罗米休斯 耶稣 穆罕默德 鲁智深 贾宝玉 孔子 等等 英雄之路的三大阶段 概括的说：故事从启程阶段开始，潜在的英雄接收到冒险召唤，初次抵触，到启蒙阶段，与智者相遇，跨越边界，开始初次尝试，到历险阶段的深入洞穴，经历严峻考验，最后到回归阶段，踏上返回之路，复活而归。 一：启程：放弃当下的环境，开始冒险 起初：平凡世界 超人的童年 彼得在成为蜘蛛侠之前 冒险的召唤 释迦摩尼遇到老人、病人、死人和苦行僧后，开始向往修行 超人偶然发现了自身的超能力 蝙蝠侠在父母遇害后，立志打击罪犯 拒绝召唤 绿巨人拒绝自身的力量，在非洲隐居 英雄得到了智慧长者的帮助，碰见导师 灰姑娘遇到的神仙教母 美人鱼遇到的巫婆 养父母肯特夫妇担当超人的导师角色 风清扬教授令狐冲独孤九剑 孙悟空立志追求长生不老时，通臂猿猴的指引 跨过第一道边界 孙悟空出海求道 超人开始担当英雄的责任 鲸鱼之腹：通过边界后进入的重生蜕变之地 二：启蒙（获得领悟）和考验（陷入险境，进行战斗） 英雄遭遇考验并遇到帮手，考验，伙伴和敌人 西游记中的取经之路，九九八十一难 《绿野仙踪》里面的小女孩桃乐丝在路上碰到了她的伙伴：稻草人，铁皮人和狮子 英雄抵达最深的洞穴，或者这个异世界的中心 西游记一行人到达了西天 阿凡达电影中的男主角进入潘多拉星球，开始反抗人类的计划 磨难，英雄的命运坠入谷底，面临死亡的危险， （也可以看做，外部的磨难伴随着内在对于生与死的看法，原来的自我认知在极限的压力下轰然倒塌，美好的幻境被打碎，一个全新的自我概念悄然形成） 西天里面的凌云渡无底船脱去凡胎，大鹏鸟抢经等 耶稣被钉十字架 钢铁侠一次又一次的战胜对手 英雄得到了圣剑，报酬（内心的升华，以及达成所愿） 圣剑，报酬可以是名誉，地位，神器，财宝，力量等 三：归来：回归正常生活（再次离开当下的舒适区）冒险归来后，英雄的整个人格已经有了很大的改变，好比如已经成为了神仙。此时再回到凡间做凡人，显然是比较困难的。此时遇到的障碍是多方面的 外界的障碍 在踏上归程的路上，会有各种各样的追踪者阻碍回归。 电影中常见的追逐场景 内心的障碍 经历冒险的内心无法适应正常生活，导致堕落。 屠龙勇士成为了恶龙 民众无法接受 英雄获得的启示、道理无法被人们所接受，导致无法回归正常生活 天龙八部里面的萧峰为了缓和宋辽两国之间的民族矛盾，换取几十年的和平，自尽身亡，究其本质是当时宋辽两国都无法接受他和平的主张 从老家离开到新的地方生活学习和工作，回到老家后会有隔阂 只有克服了种种障碍，走上归来之路，将收获到的启示，财富进行分享，与开始形成一个闭环，这段英雄之路才算是真正的走完，否则就是被困其中。 成功回归的例子： 张无忌辞去明教教主之位隐居 超人回到地面，像一个普通人一样从事报社记者的职业 哈利波特战胜伏地魔后保持低调,在家人和世人面前仍旧保持着普通巫师的形象 踏上英雄之路…… 拒绝舒适区，接受挑战 寻求朋友和导师的帮助 明确敌友，以及自己想要什么 可以忍受磨难，知道自己必须舍弃一些东西才能强大 是否战胜敌人并不重要，因为最终必有所获 神话之旅的终点是要回到当下 可以有意识的寻找自己目前的生活对应属于英雄之路哪一个阶段","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://flybids.github.io/tags/读书笔记/"},{"name":"神话学","slug":"神话学","permalink":"https://flybids.github.io/tags/神话学/"},{"name":"坎贝尔","slug":"坎贝尔","permalink":"https://flybids.github.io/tags/坎贝尔/"}]},{"title":"学箭悟禅录 杂记","date":"2020-08-02T10:40:31.372Z","path":"2020/08/02/学箭悟禅录/","text":"内容简介“德国哲学家赫里格尔先生在日本向弓道大师学习六年，回国后他记下了通过亲身体会所感悟到的东方禅文化。由于作者将抽象玄奥、高深莫测的禅和他在日本学习射箭的具体过程联系起来谈论，使得神秘的“禅”在他的笔下变得有血有肉、生动真切，因而具有特别强的感染力和说服力。此书德文原版1948年出版后，60年来，一版再版，被翻译成多种语言版本。至今仍被西方人视为了解“禅”的最佳著作之一。” ​ ——摘录自豆瓣 章节小思中和之道首先这是余觉中先生为这本书写的一篇序言。文如其名，紧扣中字，但是在我看来，余先生有失偏颇。儒家有中，佛老也有中，为何偏说儒家之中，更说自孔孟之后分为三教？显然这是不合乎实际的。由此，我对其为人治学已有怀疑。再看这本书，讲的是学箭悟禅，显然离佛更近一些，却偏偏舍近而求远，不是很奇怪么 铃木大拙序讲了属于无艺之艺的弓道，讲了禅，最后讲述了二者的联系 赫里戈尔德觉悟着重围绕觉悟展开。赫里戈尔练习弓道，是为了什么？觉悟而已。 新版译者序，初版译者序本书创作、翻译的因缘 第一章 弓道和禅弓道，也就是射箭的艺术，不能单单的看作是一种运动或者争斗之术，这种角色的属性在现当代已经渐渐失去。它更多的是一种修行炼心的精神训练手段。射的目标也不是靶子、敌人，而是我执。不单单是弓道，茶道、插花和剑道等都是如此。凡一种事，只有在意识到其具有的精神价值，便成了走向解脱的窄门。 第二章 学禅缘由作者选择禅作为其走向解脱的手段，是因为解脱是一种体验，而非分析的结果。解脱所在之地，正如空中之花，水中之火，超乎逻辑言语之外。没有体验，一切都是空话。 第三章 神意拉弓稳当的呼吸，然后得到精神的放松，继而身体得到放松，便能自然而然不可以的拉弓，也就是神意拉弓。 第四章 放箭难关作者一直找不到放箭合适的时机，总是紧张，导致放箭时身体不稳，箭也摇摇晃晃。 第五章 放下自我导师要求他放下对射的执着，然后才能在合适的时机自然的让箭射出去。 第六章 以心传心作者显然无法立刻领会，长久的失败让他自认为找到了捷径——通过技巧来弥补，但这显然是导师极为反对的。最终作者“自暴自弃”，仍然练箭，但是已经不追求射出去，这反而破除了对射箭的执着，做到了“‘它’射出去了”！ 在把箭射出去后，进入射靶子的阶段。在这个阶段和上个阶段相同。也就是这个阶段的最后，作者消除了我与射箭的界限，二者融为一体，消除了自我，也就是“弓弦现在终于能如意地切过你了”。 第七章 结业考核五年多的练习，作者终于完成了对学箭，也悟到了禅。但这只是走上解脱的开始，导师的工作也仅仅是帮他引入门口。在我看来，后面是师生，更是同道之友。 后面的章节作者首次在悟道之后，谈论了弓道与禅的关系，由此推出所有的无艺之艺，都是禅的门径，都能引人走向解脱。比如单独开辟一章讲的剑道。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://flybids.github.io/tags/读书笔记/"},{"name":"禅","slug":"禅","permalink":"https://flybids.github.io/tags/禅/"}]},{"title":"摘录《神话的力量:在诸神与英雄的世界中发现自我》","date":"2020-08-02T10:39:29.504Z","path":"2020/08/02/摘录《神话的力量在诸神与英雄的世界中发现自我》/","text":"造成所有苦难的原因，就是生命必然会死去这个事实。假如生命被肯定，死亡便无法被否定。 生命远非人智所及，它由伟大的孤寂中诞生，只有从苦难中才能触及。只有困厄与苦难才能使心眼打开，看到那不为他人所知的一 了解世界的一条可靠之路，便在书本当中。 掌管命运的三个女神会引导有志者，随波逐流的人则被她们牵着鼻子走。 生命的本质是杀生与饮食，那就是神话所要处理的重大奥秘。 这就是宗教的崇高信息，只要你在这当中至少为一个人做了事…… 真理只有一个，圣贤以许多不同的名字称呼它 生命的不完美正是它的可爱之处。 大家认为生命的意义就是人类所追求的一切。我并不这样认为。我认为人类真正追求的是一种存在的体验，因为这种体验，我们一生的生活经验才能和内心的存在感与现实感产生共鸣，我们才能真正体会到存在的喜悦。那就是生命，神话是帮助我们发现内在自我的线索。 人们的心总是在追寻意义。一朵花的意义是什么呢？ 存在本身是不需要赋予人为意义的。它就是在那里，如此而已。你的意义就是你的存在。人类一直汲汲于追求外在价值，却忘了本来便存在的内在价值，这种内在价值就是存在本身的喜悦，也就是生命的意义。 婚姻是人生中的一个神话体验。如果结婚是为了永远恋爱下去，夫妻很快便会离婚，因为所有的恋曲都会以失望告终。婚姻应该是去体验一种心灵上的契合。 我们能与合适的对象结婚，等于重新把具体化的上帝融入生活中，这就是婚姻。 婚姻是一种人际关系，如果你曾经为婚姻牺牲了什么，你并不是为对方牺牲，而是为一种关系的结合而牺牲。 婚姻不单只是谈恋爱，它是一种痛苦的体验，一种牺牲自我的痛苦体验，为的是维持两者合一的关系。 炼金术婚姻 Notes: 1) 婚姻的俩个阶段:1青春期婚姻,为了生育的目的,停在这一阶段,在孩子长大后容易分开。2炼金术婚姻,二者合为一个,削弱了单独的自我,这样是上帝祝福的。 婚姻主要是一种精神层面的学习，社会应该帮助个人意识到婚姻的这一层面。不应该由个人来配合社会，相反，社会应该为个人提供这项服务。如果由个人来迎合社会，社会就会变成一个怪物，这也是目前威胁世界稳定的因素。 旧社会的宗教属于另一个年代、另一群人、另一套人类价值、另一个世界。回到过去是将自己丢入相同的历史轮回中。我们的下一代对宗教失去信心，他们因而走入自己的内心世界。 精神崩溃是湮没在一片浮动着神秘体验的大海中，身在其中者必须要有心理准备才行。 整个生命本身就是一场冥想，其大部分过程都是非意志性的。 神话的功能便是将我们带入一种心灵层面的意识状态。 你和几百万年前的人有同样的躯体，同样的身体体验，因此你们对同样的意象会有反应。 所有的神、所有的天堂、所有的世界都在我们心中。他们是放大的梦，所有的梦都是相互冲突的身体能量通过意象表现出来的形式。这就是神话 首先，你要记住梦的内容，并且记录下来。然后截取梦里的小片段，比如一两个意象或概念，并找出它们的关联性。一次次写下你心中的意象，你就会发现梦境的基础是人生经验，这些经验在你生命中不但很重要，而且会一直影响着你，只是你不知道而已。很快你会再做梦，你对梦的解析也会更深入。 生命的真谛便是吃掉生命本身。生命依靠生命而生存。 来看生命，那是极其恐怖的。因此在蛇身上同时存在生命的迷人之处和恐怖之处。 在蛇身上同时存在生命的迷人之处和恐怖之处。 生命靠杀生及吃掉其他生命来维持，靠摆脱死亡再重生来延续，就像月亮一样。 如果你满脑子想的都是自己的原罪，那么你便会成为一个罪人。 把生命看成苦难，通过苦难，把自己从生命的桎梏中解放出来，这是较高层次的宗教。 不要评判你不评判的 我们的诞生只是一睡与一醒； 我们的生命之星、灵魂，和我们一同早起， 却在别的地方落下去， 并且来自远方。” 根据你的神话是把自然看成堕落，还是把自然和心灵本身看成神性的展现，你会有一种完全不同的文明，以及完全不同的生活方式。 坐在房间里读书、读书、再读书，而且要读对书，读对的人写的书。你的心就会被带到某个层次，你可以因此一直拥有一种美好、温和、慢慢燃烧的喜悦。这种对生命的理解，可以成为你生活中的一种常态。当你发现一个真正能抓住你心的作者时，就把他所有的作品都读完。不要说“我想知道某某某写的东西”，也不要被畅销书排行榜所困扰。 只去读这一位作者想要告诉你的。然后去读这位作者读过的东西。这时世界便以某种一致的观点豁然开朗。 当耶稣说，“爱你的邻人，就像爱自己一样”。他实际上是说，“爱你的邻人，因为他就是你自己”。 除非你有过去，否则不可能有未来。如果你爱上了现在，不论它是什么都将变成过去。失去、死亡，失去、死亡就这样周而复始下去。冥思十字架就是冥思人生奥秘的象征。 上帝的儿子到尘世来受十字架处死之苦，乃是为了让我们的心觉醒，变得慈悲，也使我们把心从对世俗生活的眷恋，转移到人类在分享苦难中特有的自我付出价值。 我和天父是一体的。 我与可敬的上帝是一体的 我的主，假如你曾教导这些人你所教我的道理，他们就不会这样对待我。假如你没有这样教我，这也不会发生在我身上。让我赞美主与它的作为” 我甚至有个迷信，因为看不见的手一直帮助我，所以我相信，如果你循着内心直觉的喜悦而行，你就走上了一条早已等待着你的轨道，你应该过的生活，就是你正在过的生活。当你可以看到这一层时，你便开始遇见你想要遇见的人，而且他们会为你开启心门。遵循你内心直觉的喜悦，不要恐惧，那么这扇门就会为你而开，而你无法预期它会带你到哪里去。 你认为你可以不经历在你之前死去的人们所经历的试炼，便能进入充满极乐的伊甸园吗？ 通往生命的门很宽，而路是窄的，极少人能发现它。 危险的道路就像剃刀的锋口一样 当你遵循欲望、热情和情绪的道路时，要不断控制你的心，别让它强行把你拖入灾难中。 奥德修斯的悲剧精神正如来自于人生美丽和优越的深度快乐。也就是窈窕淑女的高贵可爱、男子气概和男人的真正价值等。但故事的结束却是尘土灰烬 你不能因为它的终点是坟墓，就说生命是无用的。 一天的生物，它是什么？又不是什么？人只是一个阴影的梦。然而当从天堂射下一道阳光，就像对人的恩赐，人就是沐浴在阳光下的一个温柔的生命。 假如我们过自己的生活，而不是模仿他人的生活，那当然也是要经历一番寻求才能得到的。 童话是孩子的神话。不同时期的人生各有其最贴切的神话。当你年纪渐长，你需要的是让你更坚强的神话。 欲望与恐惧是控制世界上所有生命的两种情绪。欲望是饵，死亡是钓钩。 坚持你对你自己的理想，就像天行者卢克一样，拒绝外在系统强加在你身上的非人性要求。 你被你的生活所塑造。 只有你自己才可能把你内在的潜力表现在生活中，其他人都不可能。 一个人在生命里必须寻求的，绝不是一块土地或海洋，而必须是从他自己独特的经验潜能所发生的东西，是那未曾也不可能被他人经历的东西。 只有当一个人不把死亡当做是生命的对立，而是将其作为生命的一面来接受它时，人才可能体验到对生命的无条件肯定。生命在生成变化里一直在死亡中、死亡点上。克服了恐惧，生命的勇气便油然而生。无惧是每个英雄冒险历程的主要开端。 你只有一生可活，你不需要为他人而活。要活得专注! 你必须把你自己的心放在你觉得最快乐的时刻中。这种快乐不是兴奋或战栗，而是深度的喜悦。这需要一点自我分析。是什么让你快乐，你就保持它，不管别人说什么。这是我所谓的“遵循你内心直觉的喜悦”。 我们要遵循自己的路，而不是父母亲的路。 爱你的敌人，因为他们是你命运的凭借。 生命是与苦难共存的。 你吞下去的魔鬼会给你它的力量，而且越大的人生痛苦，可以得到越大的人生回馈。 你的生命是你自己行为的果实。你不能怪别人，只能怪自己。 任何人在生活中，都有体验到精神上狂喜的可能。你要做的只是去认识它、接纳它、修炼它，并与它同在。当人们说到平凡的朽物，我总觉得不舒服，因为我从未见过一个平凡的人。 发现父亲，就是发现你自己的人格特质与命运。 英雄与半神人乃是因为慈悲而生，并非为权力、性欲或维持生物生命而生。 所以人可以从动物般的肉欲，通过精神的死亡而再生。第二次出生的，是欢愉的精神生命。 “在耶稣中，没有男女。”就事物终极的意义而言，是超越两者 心是开放给另一个人的器官。这是人类不同于动物的特质，因为动物只关心自己的利益。 真正的婚姻要认识到自己与对方是一体的。生理的结合只不过是肯定这层意义的圣礼。婚姻不能反其道而行，从生理的兴趣提升到精神层次是不可能的。 对于那些在地狱里且不是天使的人来说，炼火并不是痛苦的火焰，而是欢乐的火焰。 社会的功能是在培养个体，并不是以个体来支援社会。 爱是社会许多功能中的一项。如果企图以某一种功能控制整个系统，而不是帮忙建立整个系统的秩序，那么这是会造成社会混乱的。 爱情测验在本质上是要确定这个男人会为爱而忍受一切，他不是为情欲才如此的。 是我的热情造成这个伤口，是我对这个特定个人的爱，才产生这极大的痛苦。因此唯一可以医好伤口的是开枪的人。 从我口中饮者，将成为我，而我也将成为他 婚姻就是婚姻，婚姻不是恋爱。恋爱是完全不同的一件事。婚姻是对你自己的一种承诺。你的婚姻伴侣实际上是另一半的你，而你和自己的另一半是一体的。恋爱不是这样，而是追求一种享乐的关系，而当它变得不快乐时，关系便结束。但是婚姻是一生的承诺，代表你对自己一生最主要的关怀。假如婚姻不是你的主要关怀，你等于没有结婚。 婚姻就是婚姻，婚姻不是恋爱。恋爱是完全不同的一件事。婚姻是对你自己的一种承诺。你的婚姻伴侣实际上是另一半的你，而你和自己的另一半是一体的。恋爱不是这样，而是追求一种享乐的关系，而当它变得不快乐时，关系便结束。但是婚姻是一生的承诺，代表你对自己一生最主要的关怀。假如婚姻不是你的主要关怀，你等于没有结婚。 清教徒视婚姻为“教会中的小教会”。在婚姻中我们天天在爱，天天在宽恕。它是爱与宽恕持续进行的圣礼。 婚姻就是你与自己内在女性倾向接触的方式。 爱不能使人对其他的关系免疫。但人是不是可以拥有一个完整的爱情，我是说一个真正完整的爱情，而同时还忠于婚姻呢？我认为那是不可能的。 只要是纯粹的爱情，就不会以社会同意的方式表现出来，那也是爱情如此神秘的缘故。 爱是生命的燃烧点，因为人生是悲苦的，爱也是如此。爱越强，痛苦也越大。 爱本身是苦，可以说是真正活着的痛苦。 当你凝神注视日落或山崖之美而发出‘啊’的赞叹时，你便融会在神性之中。 我们可以把奇妙、爱与恨看成是受到不同神明影响的结果。 祈祷是联系并冥想宇宙奥秘的修行。 罗马天主教有一种以念珠不断持诵同一祷辞的冥想方式，这就是把心带入修行中。在梵文中，这种修行叫做“持咒”（japa），意思是“重复神的名字”。它可以隔断其他的念头，而让你专注于一件事上，然后依据个人的想象，你可以体验到宇宙神秘力量不可测知的深度。 耶稣是历史上实际证悟到他与他所称的“天父”是“合一”的一个真实人物，而他终其一生都是以他生命本性中的基督精神而存在的。 除了神之外没有人能崇拜神 不要挑剔敌人眼中的微尘（小缺点），而要摘取自己眼中的横梁（大缺点）。没有人有资格可以否定敌人的生活方式。 爱你的敌人，并为那些处死你的人祈祷，所以你可以成为天父的子民；因为他让太阳在善与恶中升起，让雨在义与不义间降下 我愿相信。请上帝帮助我去除对你的不信 天国不会因人的祈求而到来。天国无所不在，而人却看不到它 当耶稣说，“从我口中喝水的人，将成为我，而我将成为他。”他是从所有存在物共同的存有基础，也就是我们所谓的基督这个观点出发，而有此说。任何人把这段话实践在生活中，他就等于是耶稣，这是这段话的精义所在。 当你在旅程中，发现目的地越来越远，你便认识到旅程便是真正的目的地 天国散布在每个角落，而人们看不见它。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://flybids.github.io/tags/读书笔记/"},{"name":"神话学","slug":"神话学","permalink":"https://flybids.github.io/tags/神话学/"},{"name":"坎贝尔","slug":"坎贝尔","permalink":"https://flybids.github.io/tags/坎贝尔/"}]},{"title":"JS中常见的设计模式","date":"2020-06-05T14:53:10.905Z","path":"2020/06/05/Javascript中常见的设计模式/","text":"设计模式的定义 设计模式是前人总结出的，用于解决开发中某类问题的方法，可复用的解决方案； 我们在过去的开发中已经接触过设计模式，但当时可能不清楚这就是设计模式； 设计模式之间并不是互相独立的，往往一个功能需要多个设计模式的配合来实现； 每个设计模式面向的问题不同，根据这些模式的侧重点我们可以将其分成三大类：创建型设计模式、结构型设计模式、行为设计模式。当然，除了这三种外，还有其他未包含在内的设计模式。 设计模式的好处 属于已经验证的一种解决方案 复用率高 更加具有表现力，方便沟通，描述解决方案 创建型设计模式创建型设计模式： 主要用于创建对象，即不同场景下采用不同的方式来创建对象。主要包括单例模式、工厂模式、建造者模式以及原型模式等。 1. 单例模式单例模式（Singleton）：确保一个类只有一个实例。 场景1 123456789101112/* 以完成一个弹窗的情景来理解 封装一个弹窗，确保可以多次调用该弹窗 为避免每次调用都新建一个弹窗，我们可以让所有的弹窗共用一个div元素*/let Popup = document.createElement(\"div\");Popup.show = function (arg) &#123; this.innerText = arg; document.body.appendChild(this)&#125;;Popup.show(\"张三\");//测试使用1Popup.show(\"李四\");//测试使用2 12345678910111213141516171819202122232425/* 抽象化，写成类的形式：*/let Popup = (function () &#123; let instance = null; class Pop&#123; constructor()&#123; if( instance )&#123; return instance; &#125; instance = this; this.ele = document.createElement(\"div\"); this.show = function (arg) &#123; this.ele.innerText = arg; document.body.appendChild(this.ele); &#125;; &#125; &#125; return Pop;&#125;)();let a = new Popup();a.show(\"张三\");//测试使用1let b = new Popup();b.show(\"李四\");//测试使用2console.log(a === b);//测试单例 123456789101112131415//核心实现代码let Single = (function()&#123; let instance = null; class S&#123; constructor()&#123; if(instance)&#123; return instance; &#125; instance = this; //code…… &#125; &#125;&#125;)();//实例化测试console.log( new Single() === new Single() ); 场景2 当我们直接使用字面量来定义一个对象时，该对象时唯一的，此时也可以看作单例： 123let Single = &#123; //code &#125;; 将需要用到的相关的属性或方法全部放到某对象里面，减少了对全局变量的占用，也方便使用。此外，在多人协作开发的场景下，还可以避免命名冲突的问题。 123456789101112let age = 10;let name = 'Kate';let eat = function()&#123;&#125;;// 以上几个变量可以统一放在一个对象里面let AMan = &#123; age : 10, name : 'Kate', eat()&#123; //code &#125;&#125; 1234567891011//有些时候我们希望隐藏某些变量，只有内部能访问：let AObj = (function()&#123; let NUM = 10;// 内部私有属性 return &#123; addNum()&#123; return ++NUM; &#125; &#125;&#125;)();console.log( AObj.NUM ); //undefinedconsole.log( AObj.addNum() ); // 11 总结：当需求实例唯一、命名空间时，就可以使用单例模式。 2. 工厂模式工厂模式（Factory）：通过一个统一的接口来创建指定的对象。工厂模式又包括 简单工厂模式 、抽象工厂模式和工厂方法模式两种。 场景1 1234567891011121314151617181920212223242526272829//牛排店class Steak&#123; constructor()&#123; this.price = 30; this.time = 20; &#125;&#125;//烧烤店class Grill&#123; constructor()&#123; this.price = 20; this.time = 15; &#125;&#125;//面条店class Noodles&#123; constructor()&#123; this.price = 15; this.time = 10; &#125;&#125;let a = new Steak(); //一份牛排let b = new Grill(); //一份烧烤let c = new Noodles(); //一份面条//三个类结构相似，写和调用比较繁琐、重复： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//牛排class Steak&#123; constructor()&#123; this.price = 30; this.time = 20; &#125;&#125;//烧烤class Grill&#123; constructor()&#123; this.price = 20; this.time = 15; &#125;&#125;//面条class Noodles&#123; constructor()&#123; this.price = 15; this.time = 10; &#125;&#125;//把三个类统一到一个类Shop里面class Shop&#123; constructor(name)&#123; let o = null switch(name)&#123; case \"Steak\": o = new Steak(); break; case \"Grill\": o = new Grill(); break; case \"Noodles\": o = new Noodles(); break; &#125; return o; &#125;&#125;//统一方法调用let a = new Shop(\"Steak\"); //老板来份牛排let b = new Shop(\"Grill\");//老板来份烧烤let c = new Shop(\"Noodles\");//老板来份面条 12345678910111213141516171819202122232425262728//接口已经统一，但是如果想要增加新品种菜，我们就需要再创建一个类，然后再Shop里面调用，扩展性低，所以可以将菜品类写成Shop的方法，此时只有一个Shop类：class Shop&#123; constructor(name)&#123; return this[name].call(&#123;&#125;); &#125; Steak()&#123;//牛排 this.price = 30; this.time = 20; return this; &#125; Grill()&#123;//烧烤 this.price = 20; this.time = 15; return this; &#125; Noodles()&#123;//面条 this.price = 15; this.time = 10; return this; &#125;&#125;//统一方法调用let a = new Shop(\"Steak\"); //老板来份牛排let b = new Shop(\"Grill\");//老板来份烧烤let c = new Shop(\"Noodles\");//老板来份面条//需要扩展时，仅需再Shop中增加新的方法 总结：工厂模式就是把同一类别的类综合起来，通过统一接口创建，扩展性以及可修改性高。 3. 建造者模式建造者模式（Builder）：通俗的说，就是使用多个简单的对象一步一步构建成一个复杂的对象，建造者模式又叫做生成器模式。 看名称我们首先想到的就是造房子。建造者模式就像是施工队，在了解了客户的建房需求后，将需求分解成多个子任务，分配给团队的各小组。各小组分工合作最终得到需求的房子。 场景1 1234567891011121314151617181920212223242526272829303132333435let Builder = function()&#123; //成员01 -- 决定厅室 function Rooms(member)&#123; if( member &lt;= 0 )&#123; throw new Error(\"入住人数错误！\"); &#125; this.rooms = member&gt;=3?3:2; &#125; //成员02 -- 决定面积 function FloorSpace(budget)&#123; if( (typeof budget !== \"number\") || Number.isNaN(budget) || (budget &lt; 60) )&#123; throw new Error(\"预算过低或错误！\"); &#125; this.budget = budget/2; &#125; //成员03 -- 整体风格 function Style(style)&#123; this.style = style || \"常规风格\"; &#125; return class &#123; //住几人，预算多少(万)，风格 constructor(member, budget, style) &#123; Rooms.call(this,member); FloorSpace.call(this,budget); Style.call(this,style); &#125; &#125;;&#125;();//包工头获取客户需求，然后建造房子let house1 = new Builder(1,100,\"小清新\");//客户1的需求let house2 = new Builder(4,200,\"欧美\");//客户2的需求 建造者模式中有两个重要组成，一个是建造者，如上成员01，成员02以及成员03，另一个则是把这些建造者组合起来，如上Builder。 总结：当我们构造的对象，内部结构较复杂时，使用建造者模式将内部各模块分开创建就非常合适。 4. 原型模式原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。可以看作是基于原型继承的模式，创建对象作为其他对象的原型。 场景 123456789101112131415161718192021222324252627282930//父类class Parent&#123; constructor(x)&#123; this.x = x; &#125; showX()&#123; alert( this.x ); &#125;&#125;//子类Aclass ChildA extends Parent&#123; constructor(x,y)&#123; super(); this.y = y; &#125; showY()&#123; alert( this.y ); &#125;&#125;//子类Bclass ChildB extends Parent&#123; constructor(x,z)&#123; super(); this.z = z; &#125; showZ()&#123; alert( this.z ); &#125;&#125; 总结：多个类具有相同的属性或方法，那我们就可以通过原型继承来创造出类或者实例对象。 结构性设计模式结构性设计模式 – 通常与对象组合有关，关注于将多个类或对象组合成一个大的系统，方便使用。该模式有助于确保在系统某一部分变化时，仅需改变系统中对应的部分，而不需要改变整个结构。该类模式中常见的包括外观模式、适配器模式以及装饰器模式等。 1. 外观模式外观模式（Facede）：将一组子接口统一为一个接口，这样调用起来更加方便，比较常见的应用场景就是对浏览器各种API的兼容处理。 场景 12345678910111213//以添加事件为例：使用事件添加方式 addEventListener，但是IE不兼容，需要使用attachEvent，从而添加一个click的事件写法如下：function click()&#123; //code……&#125;if( document.addEventListener )&#123; oDiv.addEventListener(\"click\" , click, false);&#125;else if(document.attachEvent)&#123; oDiv.attachEvent(\"onclick\" , click);&#125;else&#123; oDiv.onclick = click;&#125;//封装一下： 1234567891011121314function addEvent(dom , eName , fn)&#123; if( document.addEventListener )&#123; dom.addaddEventListener(eName,fn,false); &#125;else if( document.attachEvent )&#123; dom.attachEvent(\"on\"+eName,fn); &#125;else&#123; dom[\"on\"+eName] = fn; &#125;&#125;//使用addEvent(oDiv , \"click\" ,click);function click()&#123; //code……&#125; 把这些相应的兼容操作综合起来，通过外观模式就能封装成一个小型的js库。 总结：对外提供统一的接口，内部封装各种子操作。这就是外观模式。 2. 适配器模式适配器模式（Adapter）：将一个类的接口转换成另外一个接口，以满足用户需求，解决接口不一样而产生的兼容问题。 适配的概念通俗的说，可以类比读卡器、耳机转换器的作用。 场景1 123456789101112131415//某个项目中我们接口拿到的数据data是数组格式。//一段时间后，后端更新了数据结构，返回的数据变成了键值对形式，如果此时前端修改之前的代码比较复杂，就可以使用适配器模式，在拿到相应数据后，将格式转换为数组：$.ajax(&#123; success : function (msg) &#123; msg = [msg.name,msg.age,msg.marry]; //调用done done(msg); &#125;&#125;);function done(msg) &#123; for (let i = 0, length = msg.length; i &lt; length; i++) &#123; //dosomething…… &#125;&#125; 场景2 12345// 另外一种比较常见的场景是，对方法参数的处理。比如参数很多时，当使用以下方式传参，既要注意顺序，还要注意参数赋值function fn(name,age,sex,index)&#123; //dosomething……&#125;fn(\"张三\",18,1); 12345// 使用适配器模式，我们将参数合并成一个对象，在方法内部对参数对象结构获取相应的值。就可以避免以上问题function fn(options)&#123; let &#123;name,age,sex,index=1&#125;=options; //dosomething……&#125; 总结：由于各种原因，导致现有接口和之前的不一样，而修改比较麻烦时，就可以考虑使用适配器对接口进行适配。 3. 装饰者模式装饰者模式（Decorator）：在不改变原对象的基础上，对其进行包装扩展，旨在促进代码复用。看起来类似于原型模式，但是由于装饰本身对于类原有的基本功能不是必要的，不需要合并到超类，所以不选择原型模式。 12345678910111213141516171819class Book&#123; constructor(name,sex)&#123; this.name = name; this.writer = sex; &#125; showName()&#123; alert(this.name); &#125;&#125;let Abook = new Teacher(\"Abook\",\"Tom\");//code…… // 需要对实例Abook进行扩展function Decorator(obj,type)&#123; obj.type = type; return obj;&#125;Decorator(Abook,\"小说\");//code…… 总结：装饰者模式可以动态的修改对象，而不用创建新的实例。 4. 桥接模式桥接模式（Bridge）：将抽象部分与它的实现部分解耦，使得二者可以独立变化。 场景 用桥接模式联结多个类： 1234567891011121314151617181920212223242526//基本类，实现部分class A&#123; //code……&#125;class B&#123; //code……&#125;class C&#123; //code……&#125;//桥接类，抽象部分class Bridge1&#123; constructor()&#123; this.a = new A(); this.b = new B(); &#125; //code……&#125;class Bridge2&#123; constructor()&#123; this.b = new B(); this.c = new C(); &#125; //code……&#125; 总结：什么时候用到桥接？当一个系统中的多个实现部分都有相应的变化逻辑时，如果写在一起会导致结构复杂，可读性以及可维护性低。此时可以适应桥接模式，把抽象部分和实现部分分别抽离出来，然后组合使用。 5. 组合模式组合模式（Composite）：又称部分-整体模式，组合模式依据树形结构来组合对象，用来表示部分以及整体层次，使得用户对单个对象和组合对象的使用具有一致性。 常见的例子就是清理文件时，不管是删除单个文件还是文件夹都是一样的操作。 场景 1234// DOM树是典型的树形结构，// 一个典型的应用场景就是JQ对DOM元素的处理。$(\"#box\").css(\"color\" , 'red'); // 单个id为box的元素$(\".box\").css(\"color\" , \"red\"); // 一组类名为box的元素 **总结：使用组合模式将部分组合成一个整体，忽略单个对象和多个对象的使用区别，统一调用接口。 6. 享元模式享元模式（Flyweight ）：通过共享大量细粒度的对象，避免拥有相同内容造成额外的开销。 场景 1234567//最常见的享元模式，具有相同的事件函数a.onclick = function()&#123;alert(this.name)&#125;;b.onclick = function()&#123;alert(this.name)&#125;;//使用享元模式let clickEvent = function()&#123;alert(this.name)&#125;;a.onclick = b.onclick = clickEvent; 总结：享元模式就是相同的部分提出来或者采用其他形式优化掉，一般需要配合单例模式来实现。 7. 代理模式代理模式（Proxy）：为对象提供一个代理，用来控制对这个对象的访问。 代理模式就是通过代理访问对象而不是直接访问对象。具体应用可以参看ES6的Proxy。 行为设计模式行为设计模式 – 专注于不同对象之间的通信。主要包括观察者模式、访问者模式以及迭代器模式等。 1. 观察者模式观察者模式（Observer）：又叫发布-订阅模式，定义了一种一对多的关系，让多个观察者对象同时监听某一个对象，当该对象发生改变时，多个观察者对象也做出相应的改变。典型的例子就是vue响应式的实现。 组成该模式的有两个关键部分：多个订阅者 和 消息发布者。 场景 123//事件绑定的机制，其实就是一种观察者模式//事件触发的时候（发布消息）就执行对应的 事件函数（订阅者）//代码省略 2. 访问者模式访问者模式（Visitor）：在不改变对象的前提下，定义作用于对象的新操作,js中常通过call/apply来实现。 场景1 1234567891011let aMan = &#123; addInfo()&#123; this.age = 18; this.name = \"Tom\"; &#125;&#125;;aMan.addInfo();//给对象obj添加这两个属性let obj = &#123;&#125;;aMan.addAttr.call(obj); 3. 迭代器模式迭代器模式（Iterator）：在不暴露对象内部结构的同时，按顺序地访问集合对象内部的各个属性。 常见的例子比如forEach，every，map等等。在ES6里面很多功能都是基于迭代器来实现的。迭代器包括内部迭代器和外部迭代器两种。 内部迭代器 迭代的过程在方法内部完成，在外部无法干涉迭代的进度，比如forEach： 1234let arr = [1,2,3]arr.forEach(item=&gt;&#123; console.log(item)&#125;); 外部迭代器 必须通过外部的操作来执行下一步迭代，如ES6中.next()操作： 1234567let arr = [1,2,3];let arrIterator = arr[Symbol.iterator]();console.log( arrIterator.next() ); //&#123;value:1,done:false&#125;console.log( arrIterator.next() ); //&#123;value:2,done:false&#125;console.log( arrIterator.next() ); //&#123;value:3,done:false&#125;console.log( arrIterator.next() ); //&#123;value:undefined,done:true&#125; js实现一个外部迭代器迭代数组： 123456789101112var Iterator = function(arr)&#123; var index = 0, length = arr.length; return &#123; next : function()&#123; return &#123; value : arr[index++], done : index &gt;= length &#125;; &#125; &#125;&#125; ES6定义了Object.keys等相关的方法，让我们能遍历对象的属性。ES6定义的Generator函数和async函数，让我们可以手动的控制函数执行的流程。 4. 状态模式状态模式（State Pattern）：当对象内部状态发生改变时，它的行为也对应的发生改变，使之看起来像是改变了这个对象。 当需求有多种状态，并在某些条件下会从一种状态变成另一种状态时，使用状态模式就很合适。 场景 – 开关灯状态的切换 12345678910111213//不使用状态模式的常见写法const btn = document.getElementById(\"btn\");let state = \"off\";let switchFn = function()&#123; if( state === \"off\" )&#123; console.log(\"from off to on\"); state = \"on\"; &#125;else if( state === \"on\" )&#123; console.log(\"from on to off\"); state = \"off\"; &#125;&#125;;btn.onclick = switchFn; 当某状态对应的逻辑需要修改，或者需要添加新的模式时，我们需要修改整个switchFn方法。此时显而易见，各状态之间耦合性高，所以我们可以对代码进行优化如下： 12345678910111213141516171819202122232425262728293031323334// 使用状态模式let Switch = &#123; //状态机 FSM : &#123; on : &#123; to : \"off\", action : function()&#123; console.log(\"from on to off\"); &#125; &#125;, off : &#123; to : \"on\", action : function()&#123; console.log(\"from off to on\"); &#125; &#125; &#125;, //当前状态 currentState : \"off\", //初始化事件 init()&#123; const btn = document.getElementById(\"btn\"); btn.onclick = this.transition.bind(this); &#125;, //状态切换 transition()&#123; const s = this.FSM[this.currentState]; this.currentState = s.to; s.action(); &#125;&#125;; 总结：适用状态模式的常见场景： 1. 对象的行为基于它的状态，对应的操作会改变它的状态； 2. 存在大量的判断语句时，可以考虑使用状态模式进行消除。 5. 策略模式策略模式（Strategy）：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，且具有一定的独立性。简单的说，就是一个类的行为或其算法可以在运行时更改。 一系列的算法，可以相互替换，也就是说为了同一个目的，可能采取的算法不同。 场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//玩家类class Player&#123; constructor()&#123; this.totalCost = 0; this.level = \"C\"; &#125; consum(price)&#123; this.totalCost += price; let result = Strategy.calc(this.level , price); this.getLevel(); return result; &#125; getLevel()&#123; let totalCost = this.totalCost; if( totalCost &gt;= 50000 )&#123; this.level = \"S\"; &#125;else if( totalCost &gt;= 30000 )&#123; this.level = \"A\"; &#125;else if( totalCost &gt;= 20000 )&#123; this.level = \"B\"; &#125;else&#123; this.level = \"C\"; &#125; &#125;&#125;;//计价策略类let Strategy = (function()&#123; //策略 let s = &#123; S(price)&#123; return price*0.85; &#125;, A(price)&#123; return price*0.9; &#125;, B(price)&#123; return price*0.95; &#125;, C(price)&#123; return price; &#125; &#125;; return &#123; //添加新策略的接口 addsty(name , fn)&#123; s[name] = fn; &#125;, //计算策略对应最终价格的接口 calc(sty,price)&#123; if( s[sty] )&#123; return s[sty](price); &#125;else&#123; throw new Error(\"对应的优惠策略不存在！\"); &#125; &#125; &#125;;&#125;)();//测试：let afei = new Player();console.log(afei.consum(20));console.log(afei.consum(10000));console.log(afei.consum(50000));console.log(afei.consum(200)); 6. 命令模式命令模式（Command）：基于传入的参数进行驱动，将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。 场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let CanvasCmd = (function()&#123; let canvas = document.getElementById(\"canvas\"), ctx = canvas.getContext(\"2d\"); let cmdList = &#123; beginPath()&#123; console.log(1); ctx.beginPath(); &#125;, close()&#123; ctx.closePath(); &#125;, strokeStyle(color)&#123; ctx.strokeStyle = color; &#125;, moveTo(x,y)&#123; console.log(x,y); ctx.moveTo(x,y); &#125;, lineTo(x,y)&#123; console.log(x,y); ctx.lineTo(x,y); &#125;, stroke()&#123; console.log(1); ctx.stroke(); &#125;, fillStyle(color)&#123; ctx.fillStyle = color; &#125;, fillRect(x,y,width,height)&#123; ctx.fillRect(x,y,width,height); &#125;, strokeRect(x,y,width,height)&#123; ctx.strokeRect(x,y,width,height); &#125;, arc(x,y,r,begin,end,dir)&#123; ctx.arc(x,y,r,begin,end,dir); &#125; &#125;; return &#123; // 执行命令 execute(data)&#123; data.forEach(item=&gt;&#123; let &#123;command,param&#125; = item; cmdList[command] &amp;&amp; cmdList[command](...param); &#125;); &#125;, // 添加新的命令 addCmd(key,value)&#123; cmdList[key] = value; &#125;, // 移除命令 removeCmd(key)&#123; delete cmdList[key]; &#125; &#125;;&#125;)();CanvasCmd.execute([ &#123;command:\"beginPath\",param:[]&#125;, &#123;command:\"strokeStyle\",param:[\"red\"]&#125;, // other commands]); 7. 责任链模式责任链模式（Chain of responsibility）：为请求创建了一个接收者对象的链，对请求的发送者和接收者进行解耦。每个接收者都包含对另一个接收者的引用，当前接收者无法处理该请求，就会把请求交给下一个接收者。类似于原型链。 场景 情景：请假流程，小于3天，组长处理；大于3天小于5天，部门领导处理；大于5天总经理处理。 我们先按找平常的写法实现： 12345678910111213141516function request(value)&#123; if( value &lt;= 3 )&#123; console.log(\"移交组长处理。\"); //some code…… &#125; else if( value &lt;= 5 )&#123; console.log(\"移交部门领导处理。\"); //some code…… &#125; else if( value &gt; 5 )&#123; console.log(\"移交总经理处理。\"); //some code…… &#125;&#125;request(4); 判断语句太多，改用责任链模式： 12345678910111213141516171819202122232425262728//将每个分支结构分离：function director01(value)&#123; if( value &lt;= 3 )&#123; console.log(\"移交组长处理。\"); //some code…… &#125;else&#123; //移交给下一个处理人 director02(value); &#125;&#125;function director02(value)&#123; if( value &lt;= 5 )&#123; console.log(\"移交部门领导处理。\"); //some code…… &#125;else&#123; //移交给下一个处理人 director03(value); &#125;&#125;function director03(value)&#123; if( value &gt; 5 )&#123; console.log(\"移交总经理处理。\"); //some code…… &#125;&#125;//只需要从第一个处理人开始director01(10); 此时，耦合程度比上面的写法要好。但是每个处理人内部都必须强关联下一个处理人，不然就没法链式调用，耦合性还是很高，如果要添加一个处理人，那要改的地方就有该处理人上下两级，比较麻烦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//职责链类：class Chain&#123; constructor()&#123; this.successor = []; this.length = 0; &#125; setSuccessor(...rest)&#123; this.successor = rest; this.length = rest.length; &#125; request(...rest)&#123; (function getResult(index)&#123; if( index &gt;= this.length )&#123; return \"无法处理。\"; &#125; let result = this.successor[index](...rest); if( result === \"next\" )&#123; index ++; getResult.call(this,index); &#125;else&#123; return result; &#125; &#125;).call(this,0); &#125;&#125;;//将每个分支结构分离：function director01(value)&#123; if( value &lt;= 3 )&#123; console.log(\"移交组长处理。\"); //some code…… &#125;else&#123; //无须再强关联下一个处理函数 return \"next\"; &#125;&#125;function director02(value)&#123; if( value &lt;= 5 )&#123; console.log(\"移交部门领导处理。\"); //some code…… &#125;else&#123; return \"next\"; &#125;&#125;function director03(value)&#123; if( value &gt; 5 )&#123; console.log(\"移交总经理处理。\"); //some code…… &#125;&#125;//实现链let request = new Chain();//设置处理队列request.setSuccessor( director01, director02, director03,);//调用request.request(5);request.request(10); 8. 中介者模式中介者模式（Mediator）：提供了一个中介类，该类通常处理不同类之间的通信，使对象之间不再相互引用，降低他们之间的耦合，提高代码的可维护性。 1234567891011121314151617181920212223242526272829303132let mediator = (function () &#123; let topics = &#123;&#125; let subscribe = function (topic,fn)&#123; if(!topics[topic]) topics[topic] = [] topics[topic].push(&#123; ctx: this, cb:fn, &#125;) return this &#125; let publish = function (topic) &#123; let args if(!topics[topic])return false args = Array.prototype.slice.call(arguments, 1) topics[topic].forEach(item=&gt;&#123; let subscription = item subscription.cb.apply(item.ctx, args) return this &#125;) &#125; return &#123; Publish: publish, Subscribe: subscribe, init: function(obj) &#123; obj.publish = publish obj.subscribe = subscribe &#125; &#125;&#125;)() 9. 解释器模式解释器模式（Interpreter）：定义一种文法的表示，并定义一种解释器，通过这个解释器来解析对应文法的内容。 场景 – jQ提供的选择器 原生js获取DOM元素的方式是有限的，jQ给我们提供了更为复杂的选择方式，比如：$(&quot;#box p&quot;)，这个参数规则就是jQ定义的一套选择元素的文法，而解析这个字符串，使之获取对应DOM元素的代码就是解释器。","tags":[{"name":"js","slug":"js","permalink":"https://flybids.github.io/tags/js/"},{"name":"设计模式","slug":"设计模式","permalink":"https://flybids.github.io/tags/设计模式/"}]},{"title":"组件间的通信—派发（dispatch)和广播（broadcast)","date":"2019-08-01T01:35:46.098Z","path":"2019/08/01/组件间的通信—派发（dispatch)和广播（broadcast)/","text":"根据前文，provide/inject的使用具有局限性，对于父子组件的通信必须有其他的办法。 $on 和 $emit在当前vue.js中，较常用的是$on 和 $emit。$emit主要用来触发事件，而$on用来监听被触发的事件。一般来说，子组件中使用$emit，父组件中使用$on。二者具体的用法如下： 1234567891011121314&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt; &lt;slot&gt;确定&lt;/slot&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export defalut&#123; methods:&#123; handleClick()&#123; this.$emit(&apos;parent&apos;,&apos;123&apos;) &#125; &#125; &#125;&lt;/script&gt; 123456789101112&lt;template&gt; &lt;i-btn @parent = &apos;test&apos;/&gt;&lt;/template&gt;&lt;script&gt; export default&#123; methods:&#123; test(data)&#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt; dispatch 和 broadcast上述写法一般只能用于一级的父子组件，那么对于多级，在1.x版本的vue.js中使用dispatch 和 broadcast。 dispatch: 子组件向所有的父组件分发，从最近的向远处传播 broadcast: 父组件向子组件广播，从近到远 他们传递的事件一旦被某组件通过$on监听到了，就会停止冒泡下去。可惜的是，在新版本vue.js中已经被废弃。 自主实现dispatch 和 broadcast预计功能：可以向父级组件或子组件，由近到远传播查询，直到找到对应的组件（更据唯一组件name是否一致），然后在改组件中进行监听。 需要传的参数：目标组件名，事件名，事件中用到的参数 具体代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// emmiter.js/** * 父组件向子组件广播事件 * @param cName 目标组件名 * @param eName 事件名 * @param eData 事件参数 */function broadCast(cName,eName,eData)&#123; let children = this.$children children.forEach(ele =&gt; &#123; let name = ele.$options.name if(name === cName)&#123; ele.$emit.apply(ele,[eName].concat([eData])) &#125; else&#123; broadCast.apply(ele,[cName,eName].concat([eData])) &#125; &#125;);&#125;/** * 子组件向父组件分发事件 * @param cName 目标组件名 * @param eName 事件名 * @param eData 事件参数 */function dispatch(cName,eName,eData)&#123; let parent = this.$parent || this.$root let name = parent.$options.name while(parent &amp;&amp; (!name || name!== cName))&#123; parent = parent.$parent if(parent)&#123; name = parent.$options.name &#125; &#125; if(parent)&#123; parent.$emit.apply(ele,[eName].concat([eData])) &#125;&#125;export default&#123; methods:&#123; broadCast(cName,eName,eData)&#123; broadCast.call(this,cName,eName,eData) &#125;, dispatch(cName,eName,eData)&#123; dispatch.call(this,cName,eName,eData) &#125; &#125;&#125; 12345678910111213141516// c-a.vue &lt;tempalte&gt; &lt;button @click=&apos;handleClick&apos;&gt;确认&lt;/button&gt;&lt;/tempalte&gt;&lt;script&gt; import Emmiter from &apos;../mixins/emmiter.js&apos; export default&#123; mixins: [Emmiter] name: &apos;c-a&apos;, methods:&#123; handleClick()&#123; this.broadCast(&apos;c-b&apos;,&apos;test&apos;,&apos;当前组件的数据传给子组件&apos;) &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819// c-b.vue &lt;template&gt; &lt;i-btn @test=&quot;out&quot;/&gt;&lt;/template&gt;&lt;script&gt; import &apos;iBtn&apos; from &apos;../c-a&apos; export default&#123; components:&#123;iBtn&#125;, name:&apos;c-b&apos;, // created()&#123; // this.$on(&apos;test&apos;,this.out) // &#125;, methods:&#123; out(data)&#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"组件间的通信-开始","date":"2019-08-01T01:35:46.098Z","path":"2019/08/01/组件间的通信/","text":"了解一个组件，最基础的三个部分： prop, slot 以及 event。 prop prop定义了该组件有哪些属性是可配置的，对于prop最好使用对象的写法，这样就可以对传入的prop进行校验。 12345678910props:&#123; size:&#123; validator(value)&#123;return test(value)&#125;, default: \"default\" &#125;, page: &#123; type: Number, defalut: 0 &#125;&#125; slot 插槽，主要用来对组件进行扩展，可以是文字，也可以是html或者其他组件。 1234&lt;i-button&gt;按钮 1&lt;/i-button&gt;&lt;i-button&gt; &lt;strong&gt;按钮 2&lt;/strong&gt;&lt;/i-button&gt; 以上是单独一个插槽，也可以使用多个插槽。插槽也可以是命名的插槽。 默认显示内容 1234&lt;i-button&gt; &lt;i-icon slot=\"icon\" type=\"checkmark\"&gt;&lt;/i-icon&gt; 按钮 1&lt;/i-button&gt; event 对于自定义的事件，会使用到$emit, 具体的代码如下： 123456789101112&lt;template&gt; &lt;button @click=&quot;test&quot;&gt;BUTTON&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; methods:&#123; test(event)&#123; this.$emit(&apos;f-click&apos;,event) &#125; &#125; &#125;&lt;/script&gt; 1&lt;i-btn @f-click=\"tan\"/&gt; tips: 对于一些可能和原生事件混淆的自定义事件（如click），可以通过@click.native来区别 接着讲进入本系列的主题——组件间的通信。 组件间的关系可以分为父子关系，兄弟关系。针对父子关系，又可以包含多代父子。组件通信方式多凭借$parent,$children,ref等。 父子组件通信可以通过$parent,$children,但是这只能针对于一代的父子；如果相隔多代，就不可行了。 使用ref的简单例子如下： 12345...&lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;...this.$refs.comA... 所以在实际组件的开发中，我们会考虑使用别的方法。","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"变量的解构赋值","date":"2019-08-01T01:35:46.097Z","path":"2019/08/01/变量的解构赋值/","text":"数组解构赋值123456let [a,b,c] = [1,2,3];let [x, , y] = [1, 2, 3];let [head, ...tail] = [1, 2, 3, 4];let [x, y, ...z] = ['a']; // x=a,y=undefined,z=[]let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'let [x, y, z] = new Set(['a', 'b', 'c']); // x='a' 对象解构赋值1234567let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // foo-&gt;aaa,bar-&gt;bbblet &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // baz-&gt;undefinedconst &#123; log &#125; = console;log('hello') // hellolet &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // baz-&gt;foo-&gt;aaa,foo-&gt;undefined 注意点1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 字符串解构赋值123const [a, b, c, d, e] = 'hello'; // a-&gt;'h',...let &#123;length : len&#125; = 'hello'; //len:5 数字和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 函数参数解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 圆括号()问题ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。建议只要有可能，就不要在模式中放置圆括号。","tags":[{"name":"js","slug":"js","permalink":"https://flybids.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://flybids.github.io/tags/es6/"}]},{"title":"基础组件开发二三事","date":"2019-08-01T01:35:46.097Z","path":"2019/08/01/组件开发流程/","text":"Keys初始化项目 123vue create my-projectyarn add vue-router // 安装routeryarn add async-validator // 常用的校验库 项目结构调整123456789101112131415++ src++++ assets --静态资源，如图片等++++ components ++++++form ++++++++form.vue++++++++form-item.vue++++++input++++++++input.vue++++ mixins --用来混入++++++emmiter.js --实现dispatch和broadcast++++ views++++++Form.vue++++ main.js++++ App.vue++++ router.js --路由 router.js推荐使用组件按需加载的方式，也就是懒加载，可以节省页面初始化的时间。 1234567891011121314export default new Router(&#123; routes: [ &#123; path: '/', name: 'home', component: Home &#125;, &#123; path: '/form', name: 'form', component: ()=&gt;import('./views/Form.vue') &#125; ]&#125;) mixin写法1234567import test from '../../test.js' //混入make方法export default&#123; mixins: [test], methods:&#123; this.make() &#125;&#125; 父子组件通信 通过自定义的dispatch和broadcast传递事件 在组件中通过$on监听被触发的事件 组件渲染顺序是从内到外的，子组件的mounted在父组件的mounted之前，在父组件的created之后。所以，应该在父组件的created里面监听事件。 如果只是单纯的传递数据，状态等，可以结合实际，考虑使用provide/inject（可以给所有子组件通过注入的方式使用，类似vux) 和 props(一级一级的传) 常用易混淆的JS方法 filter forEach every every()是对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 some()是对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。 filter()是对数组中的每一项运行给定函数，返回该函数会返回true的项所组成的数组。 forEach() 是多数组中的每一项运行给定函数，这个方法没有返回值。它只是对数组中的每一项运行传入的函数，没有返回值。本质上与使用for循环迭代数组一样。 apply call bind call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 立即执行 12func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]); bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。 不立即执行，只是创建一个函数 12var boundGetNum = getNum.bind(mymodule);boundGetNum(); AsyncValidator的使用 async-validator异步验证，需要传入验证的规则和需要验证的数据。 1234567// 验证的规则ruleValidate: &#123; name: [ &#123; required: true, message: \"用户名不能为空\", trigger: \"blur\" &#125;, &#123; type:'email', message:'必须为邮箱格式', trigger: \"blur\" &#125; ], &#125; 12345// 需要验证的数据格式&#123; a: xxx, b: xxx&#125; 1234567891011// 验证的通用代码let descriptor = &#123;&#125;;descriptor[this.prop] = rule; // descriptor['name']const validator = new AsyncValidator(descriptor); // 封装验证器let model = &#123;&#125;;model[this.prop] = this.filedValue; // 封装验证的数据validator.validate(model, &#123; firstFields: true &#125;, errors =&gt; &#123; this.validateState = !errors ? 'success' : 'error'; this.validateMessage = errors ? errors[0].message : ''; callback(this.validateMessage); // callback是回调函数&#125;); 调用子组件的方法给子组件一个ref = ‘test’ this.$refs.test.方法()","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"如何更快加载HTML页面","date":"2019-08-01T01:35:46.097Z","path":"2019/08/01/更快加载HTML页面的一些策略/","text":"减少页面的大小排除不必要的空格，注释，内嵌脚本等。 最小化文件数量减少文件引用的数量，也就是降低http请求次数。 减少域名查找每个独立的域名都会耗费DNS查找时间，所以在页面中尽量少的使用来自不同域名的地址 缓存重用的内容确保会被多次使用的内容被缓存，下次加载减少渲染时间 高效排列页面组件页面最初显示时，会先下载页面内容和所需的js以及css。而页面中具有动态特性的资源需要在页面完全加载之后，才会被使用。所以，最好在初始化时关闭动态特性（disable dynamic features ），等页面加载完后再打开它。这样JavaScript就会在网页内容之后才加载，有助于提升页面加载的整体表现。 减少内联脚本使用CSS和合法标志给内容分块指定图像和表格的大小合理选择user-agent尽量使用async和defer1234567891011121314&lt;!--没有 defer 或 async，浏览器会立即加载并执行指定的脚本，不等待后续载入的文档元素，读到就加载并执行 --&gt;&lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;!--加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。--&gt;&lt;script async src=\"script.js\"&gt;&lt;/script&gt;&lt;!--有defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；--&gt;&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt; 更多相关见本链接 页面结构示例HEAD LINK … CSS 文件用来修饰页面外观。在调试维护中把不相关的 CSS 拆分在不同文件中，且尽量减少文件的数量可以提高性能。 SCRIPT … JavaScript 文件用来实现页面加载时的一些功能，但不是所有的 DHTML 在页面加载后才能运行。在调试维护中把不相关的 JavaScript 拆分在不同文件中，且尽量减少文件的数量可以提高性能。· BODY 在一块组件（tables / divs）中用户可见的页面内容，不必等页面完全加载也能显出来的。 SCRIPT … 被用来支持动态页面（DHTML）展示的脚本。 DHTML 脚本通常在页面完全加载或者所有必要的对象（objects）已初始化完毕之后才能运行。没有必要在页面内容之前加载这些脚本，这只会拖慢页面加载和初始化的体验。在调试维护中把不相关的 script 拆分在不同文件中，且尽量减少文件的数量可以提高性能。如有图像用到了反转效果，你应该在页面内容下载完后预加载这些图像。","tags":[{"name":"html","slug":"html","permalink":"https://flybids.github.io/tags/html/"}]},{"title":"组件间的通信-provide/inject","date":"2019-08-01T01:35:46.097Z","path":"2019/08/01/组件间的通信-projectinject/","text":"在实际开发中，对于比较复杂的组件间的通信，我们一般会引入vux等第三方库。但是在单独开发组件，不考虑引入第三方资源，如开发组件库时，我们可以使用vue内置的provide和inject。 provide相当于主动提供，而inject是依赖注入。 如何理解provide和inject?直接看代码。 12345678910111213141516// 父级组件提供 'foo' 给所有子组件var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;// 子组件注入 'foo'var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // =&gt; \"bar\" &#125; // ...&#125; provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中 他们的局限在于，多用于子组件获取父组件的状态，对于父子组件的通信就不适用。对此，见下文。","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"vuejs运用机制概览","date":"2019-08-01T01:35:46.096Z","path":"2019/08/01/vue-源码学习总结(一)/","text":"序言在断断续续做过一段时间的vue项目之后，不久又掘金上看到的vue学习小册，简单浏览一遍，受益良多。所以简单的通过摘录，笔记的形式，边学习便记忆，加深自己对vue原理的理解，并帮助自己日后进一步的研究vue的源码。 总览vue 初始化和加载 在 new Vue() 之后，会调用 vue._init() 函数进行初始化，包括生成生命周期，事件，props, data, methods, computed, watch 等等。 最主要的是通过Object.defineProperty设置setter和getter函数，实现响应式和依赖采集； 初始化之后，通过$mount 挂载组件，存在template时，需要进行编译。 编译 parse阶段 借助正则表达式解析template中的css,class,style,指令等，生成AST optimize阶段 标记静态节点，这样以后update页面需要通过patch来比较渲染dom的时候，会跳过静态节点，从而减少比较的时间，提升patch的性能，对编译过程实现优化。 generate阶段 将AST转换为render function字符串等。 经过以上三个阶段之后，组件中就会存在渲染VNode节点需要的函数。 响应式 在初始化阶段，我们设置了getter和setter方法，分别在读取和赋值的时候触发。 渲染组件的时候，会进行读取操作，触发getter函数，实现依赖收集，将观察者watcher收集放入当前闭包的订阅者Dep里面； 对组件进行修改时，会触发setter函数，setter会通知之前收集的所有观察者，让他们重新渲染视图。在渲染过程中，有用到update和patch等。 Virtual DOMrender function 生成 vNode 节点，这些节点组成 vDom(js对真实DOM的抽象) 更新视图","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"vuejs组件相关","date":"2019-08-01T01:35:46.096Z","path":"2019/08/01/vuejs组件相关/","text":"基础 组件的data选项必须是个函数，这样每个实例都可以维护被返回对象的独立的拷贝。也就是，使用多个组件时(如组件复用时），彼此不会相互干扰。 12345678// 错误用法data:&#123;count : 0&#125;// 推荐用法data: function()&#123; return &#123; count: 0; &#125;&#125; 通常一个应用会以一颗嵌套的组件树的形式组织。在使用组件时，必须先注册组件，注册组件的方式包括全局注册和局部注册两种。全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。 1234// 全局注册Vue.component(&apos;my-component-name&apos;, &#123; // ... options ...&#125;) props接收父组件传来的数据 123456789// 子组件Vue.component(&apos;blog-post&apos;, &#123; props: [&apos;title&apos;], template: &apos;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&apos;&#125;)// 父组件&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt; 组件必须只能是单个根组件 监听子组件事件，也可以理解为子组件传数据到父组件，和props相反 12345678910// 父组件 接受enlarge-text值，并 +0.1&lt;blog-post ... v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;// 子组件 blog-post发送enlarge-text值&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt; Enlarge text&lt;/button&gt; 插槽的使用 1234567891011121314// 使用组件&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt;// 组件Vue.component(&apos;alert-box&apos;, &#123; template: ` &lt;div class=&quot;demo-alert-box&quot;&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 效果如下： Error! Something bad happened. 动态组件 有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里，进行tab页的切换效果。 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; currentTabComponent可以包括已注册组件的名字或者一个组件的选项对象。 深入组件组件的注册 注册组件是，需要给组件名 组件名的命名要求语义化，同时小写，推荐xxx-xxx-xxx形式 局部注册组件的使用示例： 1234567import ComponentA from &apos;./ComponentA.vue&apos;export default &#123; components: &#123; ComponentA &#125;, // ...&#125; 对于通用的基础组件，如按钮，输入框等等，可以使用 require.context 只全局注册这些非常通用的基础组件。 1234567891011121314151617181920212223242526272829303132333435363738//在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码import Vue from 'vue'import upperFirst from 'lodash/upperFirst'import camelCase from 'lodash/camelCase'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = upperFirst( camelCase( // 获取和目录深度无关的文件名 fileName .split('/') .pop() .replace(/\\.\\w+$/, '') ) ) // 全局注册组件 Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) Prop Prop的大小写，推荐kebab-case,也可以camelCase 12345Vue.component(&apos;blog-post&apos;, &#123; // 在 JavaScript 中是 camelCase 的 props: [&apos;postTitle&apos;], template: &apos;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&apos;&#125;) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; props可以参数类型检查 123456789101112131415161718192021222324252627props: &#123; title: String, // 多个可能的类型 likes: [String, Number], isPublished: Boolean, commentIds: Array, // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;,// 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 &#125; &#125; author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 使用 title=”value”的形式实现传递静态Prop,:title=”value”传递动态Prop。prop可以是数字，布尔值，数组，对象。 单向数据流，从父组件到子组件。如果在子组件中修改prop，会发出警告。 自定义事件 事件名始终使用kebab-case的形式，因为事件名不同于组件和prop，不会自动转换大小写，所以可能无法匹配。 自定义组件的v-model 12345678910111213141516Vue.component(&apos;base-checkbox&apos;, &#123; model: &#123; prop: &apos;checked&apos;, event: &apos;change&apos; &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&apos;change&apos;, $event.target.checked)&quot; &gt; `&#125;) 1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt; 将原生事件绑定到组件的根元素上，可以使用.native,但是当这个根元素无法触发该事件，如label无法触发focus事件时，此时改绑定事件将失效。 1&lt;test-input v-on:focus.native = &quot;onFocus&quot;&gt;&lt;/test-input&gt; 某些情况下，需要对父组件传给子组件的prop进行双向绑定，此时就需要这样写： 1&lt;text-document :title.sync = &quot;doc.title&quot;&gt;&lt;/text-document&gt; 1this.$emmit(&apos;update:title&apos;,newTitle) 插槽插槽内容 \\123&lt;navigation-link url=&quot;/profile&quot;&gt; 可以是文本，HTML,组件等&lt;/navigation-link&gt; 123456&lt;a v-bind:href=&quot;url&quot; class=&quot;nav-link&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 作用域12345678&lt;navigation-link url=&quot;/profile&quot;&gt; Clicking here will send you to: &#123;&#123; url &#125;&#125; &lt;!-- 这里的 `url` 会是 undefined，因为 &quot;/profile&quot; 是 _传递给_ &lt;navigation-link&gt; 的而不是 在 &lt;navigation-link&gt; 组件*内部*定义的。 --&gt;&lt;/navigation-link&gt; 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 动态组件&amp;异步组件动态组件中使用keep-alive切换组件时，会保持这些组件的状态，避免重复渲染。 1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 处理边界情况访问元素&amp;组件 根实例 this.$root 父级组件实例 this.$parent 子组件实例 1&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt; 1this.$refs.usernameInput","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"let 和 const","date":"2019-08-01T01:35:46.096Z","path":"2019/08/01/let-和-const/","text":"let 命令基本用法let 变量的作用域是在其对应的代码块，var 的变量是全局变量，会挂载在顶层变量上。 对于for循环，设置循环变量的作用域是父作用域，循环体内部是单独的子作用域。同名变量在子作用域会覆盖父作用域传来的值,但是在父作用域对应变量值不受影响。具体如下： 1234567for(let i =0;i&lt;3;i++)&#123; let i ='abc' console.log(i)&#125;//abc//abc//abc 变量提升对于用let和const声明的变量不会发生变量提升，而使用var会发生变量提升。所以，var变量在声明前使用不报错，而let和const会报错。 变量提升：js从上到下执行时，分为词法分析和执行两个阶段。在词法分析阶段，包括分析形参，分析变量，分析函数声明三个部分。经过词法分析后，会将存在的变量声明和函数声明，进行一番处理，比如赋值等。具体代码如下： 12console.log(a)var a =12 词法分析后的代码为： 123var a = undefinedconsole.log(a)a=12 运行的结果是： 1undefined 暂时性死去TDZ由于let/const不会变量提升，在作用域内，变量声明之前的部分，对于该变量都属于死区，也就是暂时性死区。 TDZ导致typeof运算符不再安全，当在变量X的暂时性死区中使用typeof检验X时，此时会抛出ReferenceError。 不允许重复声明块级作用域使用{ 和 } 包裹的作用域 let &amp; constconst声明只读变量，必须赋值，一旦声明就不能改变它的值。但是如果声明的是个对象时，可以改变对象的属性值。本质上，不可改变的是指针指向的对象，或者说内存地址所保存的数据不得改动。对于字符串，数字等简单变量，内存地址保存的就是它的值，但是对于对象，数组等保存的是指向数据的地指针。 const变量的作用域只在声明的块作用域有效，没有变量提升，有TDZ. 冻结对象12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 123456789// 将对象本身冻结，对象的属性也冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 声明变量6种方式 var function let const class import","tags":[{"name":"js","slug":"js","permalink":"https://flybids.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://flybids.github.io/tags/es6/"}]},{"title":"vuejs基础拾遗（一）","date":"2019-08-01T01:35:46.096Z","path":"2019/08/01/vuejs拾遗/","text":"序言在学习并使用vue框架开发了几个项目后，发现自己对vue的一些基本属性和概念有所疏漏。闲暇之余，便重拾vue官网文档，见有不熟悉之处，便摘录余下。以后时有更删。 Vue实例创建实例1new Vue(&#123;&#125;) 数据与方法可以使用Object.freeze()冻结一个对象，使对象的属性无法被修改，但是响应式系统也无法追踪变化。 123let obj = &#123;foo : &apos;bar&apos;&#125;Object.freeze(obj)new Vue(&#123;el:&apos;#app&apos;, data:obj&#125;) 生命周期 生命周期函数不建议使用箭头函数，否则会有this的指向问题 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 模板语法插值 原始HTML,把插值按照HTML进行解析 动态渲染任意HTML比较危险，容易导致xss攻击。只对可信内容使用HTML插值，绝不对用户提供的内容使用插值。 123&lt;p&gt; Using: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt; 使用v-once指令，一次性插值，当数据更新时，插值处的内容不更新。 1&lt;span v-once&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt; 指令 v-if v-show v-bind 等同于 : 绑定值 v-on 等同于@ 绑定dom事件 计算属性和侦听器计算属性 对于任何复杂逻辑，都应当使用计算属性 12345678910111213141516&lt;p&gt; &#123;&#123; reverseMsg &#125;&#125;&lt;/p&gt;&lt;script&gt;var vm = new Vue(&#123;el:&apos;#example&apos;,data:&#123;msg: &apos;Hello&apos;&#125;,computed:&#123;reverseMsg: function()&#123;return this.msg.split(&apos;&apos;).reverse().join(&apos;&apos;)&#125;&#125;&#125;)&lt;/script&gt; vs methods computed中的方法动态绑定相关的值，如上述的msg.当msg变化时，会重新执行渲染。同时，只要msg没有变化，即便多次使用reverseMsg也不会重复执行多次reverseMsg，相当于缓存。 vs watch 可以使用computed的话，就不要使用watch.使用watch可能代码重复等。 setter 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 侦听器当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 watch 选项之外，您还可以使用命令式的 vm.$watch API。 Class与Style绑定绑定HTML Class 对象语法 12345678910111213141516171819&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;script&gt;data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt; .active&#123;&#125; .text-danger&#123;&#125;&lt;/style&gt; 数组语法 12345&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; 渲染为： 1&lt;div class=\"active text-danger\"/&gt; 用在组件上 当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 绑定内联样式 对象语法 1234567&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125;&lt;/script&gt; 更推荐： 1234567&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125; 数组语法 将多个样式对象应用到同一个元素上 1&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 自动添加前缀 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值 v2.3.0+ 为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值。 1&lt;div :style=&quot;&#123; display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] &#125;&quot;&gt;&lt;/div&gt; 在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 条件渲染v-if vs v-show v-if v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 如何选择 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 不推荐同时使用 v-if v-forv-for 具有比 v-if 更高的优先级 列表渲染v-for v-for = “item in items” v-for = “item of items” 可以遍历对象和数组，在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。 对象更改检测注意事项由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除。 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。 1Vue.set(vm.userProfile, &apos;age&apos;, 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名。 1vm.$set(vm.userProfile, &apos;age&apos;, 27) 过滤和排序有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法。 一段取值范围v-for 也可以取整数。在这种情况下，它将重复多次模板。 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 渲染为： 11 2 3 4 5 6 7 8 9 10 v-for on a \\类似于 v-if，你也可以利用带有 v-for 的 &lt;template&gt; 渲染多个元素。 123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://flybids.github.io/tags/vue/"}]},{"title":"html相关总结","date":"2019-08-01T01:35:46.095Z","path":"2019/08/01/html相关总结/","text":"常见元素 适配移动端 第一步在head的meta上添加viewwidth=mediawidth form表单 form表单元素提交方式有get和post两种形式，其中对于post，又有encode和formData两种数据格式，后者一般在需要上传文件时使用。 在使用表单元素的时候，可以不用form进行包裹，但是建议使用，原因包括： form表单中可以使用按钮的reset,submit等功能 jQuery等库中有使用到form表单 在一些框架中，使用form可以更好的进行数据校验 有form的时候，用户可以通过浏览器记住密码等。 其他 如何理解HTML 是一个文档 结构 语义化 版本 html5新增元素 语义化 块： section&lt;article nav aside 语义化： header footer form: 新增校验 autofocus em strong i icon 图标 html5的特性 回归html4, 更宽松，更语义化 更多的特性反映在动态特性中，需要结合js才能体现，如本地存储，websocket等等 元素分类 根据样式分类 block inline inline-block 根据内容分类，彼此互相交叉 Flow 可见的 Heading 标题 section 分区 Interactive 可交互动 Phrasing 短语 Metadata 资源 元素嵌套关系 块元素包含行内元素 块元素不一定可以包含块元素 行内元素一般不可以块元素，但是a例外 元素默认样式和定制化 在不同的浏览器中，元素的默认样式可能有所不同，这就需要我们定制化样式。 需要注意的问题 浏览器中读取的是dom，dom是根据html解析获取","tags":[{"name":"html","slug":"html","permalink":"https://flybids.github.io/tags/html/"}]},{"title":"Hello World","date":"2019-08-01T01:35:46.095Z","path":"2019/08/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"git 高阶","date":"2019-08-01T01:35:46.094Z","path":"2019/08/01/git-高阶/","text":"rebase和merge使用merge会使commit的历史中出现分叉，这种分叉再汇合的结构显得混乱，难以管理。此时就需要用到rebase变基。 rebase: 把你指定的 commit 以及它所在的 commit 串，以指定的目标 commit 为基础，依次重新提交一次。 动态示意图： merge 1git merge branch1 rebase 12git checkout branch1git rebase master 另外，在 rebase 之后，记得切回 master 再 merge 一下，把 master 移到最新的 commit： 12git checkout mastergit merge branch1 A—B—C topic / D—E—F—G master &gt;==git rebase master ==&gt; A’–B’–C’ topic / D—E—F—G master 应用场景： 我在主分支commit a时新建了新分支，此时开始分叉，分叉后我又在主分支改了东西commit b，此时我后悔了，我不该在commit a时分叉的，因为commit b的东西我新分支也需要，此时用衍合，就等于我丢弃原分叉，在commit b重新分叉（原分叉的改动内容当然也是带上的，没有丢） commit时提交的文件存在错误1234## 修正文件git add 1.text## 重新commit，当前commit会替换掉之前的commitgit commit --amend 取消当前的commit12git reset --hard HEAD^## 撤销的提交并没有消失，只是失效了 取消之前的commit123git rebase --onto HEAD^^ HEAD^ branch1## 以倒数第二个 commit 为起点（起点不包含在 rebase 序列里哟），branch1 为终点，## rebase 到倒数第三个 commit 上。 1234## 在编辑界面中删除想撤销的 commitsgit rebase -i 哪一个commit## 在 rebase 命令中直接剔除想撤销的 commitsgit rebase --onto 哪一个commit 错误的代码push到中央仓库了错误代码还在自己的分支上修改或删除错误的commit,然后push 如果本地在上次commit之后有了修改，再push会失败，可以强行push 1git push origin branch1 -f 错误代码已经合并到master123## 撤销错误的提交（相当于增加相反的commit，覆盖之前的commit）git revert HEAD^## 然后push reset用途reset命令的本质：重置HEAD和他所指向的branch的位置 更具参数的不同，有不同的用途： –hard：重置位置的同时，清空工作目录的所有改动； –soft：重置位置的同时，保留工作目录和暂存区的内容，并把重置 HEAD 的位置所导致的新的文件差异放进暂存区。 –mixed（默认）：重置位置的同时，保留工作目录的内容，并清空暂存区。 checkout 本质checkout不仅可以用来切换分支，其本质是签出指定的commit 123git checkout branch1git checkout HEAD^git checkout master~5 checkout只带着head走，reset带着head和branch一起走 stash临时需要切换分支，当前分支的改动不想提交，但是需要暂存起来，之后切换回来时可以再取出来 没有没跟踪(tack)过的（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们），需要先add,然后stash 1234## 存git stash## 取git stash pop 恢复删除的branch123456## 查看历史git reflog## 假设HEAD 的最后一次移动行为是「从 branch1 移动到 master」。而在这之后，branch1 就被删除了。## 所以它之前的那个 commit 就是 branch1 被删除之前的位置了，也就是第二行的 c08de9a。git checkout c08de9agit checkout -b branch1","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"git深入学习之VCS","date":"2019-08-01T01:35:46.094Z","path":"2019/08/01/git深入学习之VCS/","text":"什么是版本控制系统VCS最基本功能：版本控制保留对文件的修改历史，方便撤销更改和回退到指定版本 主动提交多人合作的同步需求：中央仓库所有人的改动都推送到中央仓库，所有人都可以从中央仓库看到和下载别人的改动 两种版本控制系统中央式版本控制系统 CVCS工作模型A,B,C三人共同参与一个项目的开发，假设有一个中央仓库O,BC从O中同步获取A的代码，然后三人开始同步开发。每次有人提交代码到O时，另外两人可以将这些最新代码从O同步到本地。 中央仓库功能 保存版本历史 同步团队代码 分布式版本控制系统 DVCSDVCS和CVCS的区别是，除了有一个共同的中央仓库意外，本地也有一个仓库，记录了所有的本地版本历史。 中央仓库功能保存版本历史的功能转给本地仓库，中央仓库的功能更多的偏向于同步团队代码。 工作模型 主工程师在本地仓库提交代码 搭建中央仓库，把本地仓库代码推送到中央仓库 其他成员从中央仓库同步代码到本地仓库，开始并行开发 成员将本地的每一个需要提交的改动提交到本地仓库 完整的功能开发完毕后，再将代码从本地仓库推送到中央仓库 每次有人推送代码时，其他人可以将最新代码同步到本地仓库 优点和确点优点 多数操作可以本地进行，不受工作环境网络限制 由于可以本地提交，可以分步提交代码，把代码提交做的更详细，方便review 缺点 初次获取项目clone耗时长 每个机器都有本地仓库，占内存比较大","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"git 进阶","date":"2019-08-01T01:35:46.094Z","path":"2019/08/01/git-进阶/","text":"head master 和 branchhead:当前commit的引用当前commit指的是当前工作目录对应的commit branch：分支如果我在这时创建一个 commit，那么 HEAD 会带着 master分支 一起移动到最新的 commit master是默认的分支,git clone时会自动checkout到master 分支的创建 切换 删除12345678910## 创建分支git branch branch1## 切换分支git checkout branch1## 合并以上两条命令，创建并切换分支git checkout -b branch1## 删除分支,没有合并到主分支上的分支(分支上的内容已经被追踪或者已经被commit)删除会失败git branch -d branch1## 确认删除,不考虑有没有mergegit branch -D branch1 push的本质 push是上传当前的分支，并上传当前分支的所有commit push时，如果当前分支是本地新创建的一个分支，需要指定远程仓库名和分支名 1git push origin branch1 push的时候之后上传当前分支，并不会上传HEAD；远程仓库的HEAD是永远指向默认分支（即master)的。 merge合并commits指定一个commit,合并到当前commit 123## 当前分支是A,需要合并的分支是Bgit merge B## 此时，B被合并到A上面 merge应用场景 一个分支开发完毕，需要合并到原来的分支 pull的内部操作 特殊情况 冲突 一个分支修改A文件，另一个分支修改B文件，合并时自动完成 一个分支修改A文件的第100行，另一个分支修改A文件的第20行，合并时自动完成 当修改同一文件的同一位置，无法自动完成，会出现冲突。 解决冲突 手动合并 add =&gt; commit 如果放弃解决冲突，可以取消merge,回到merge前的状态 1git merge --abort head领先于当前commit 此时，merge时的commit与Head处的commit之前不存在分叉，没有什么需要合并的，所以不会进行合并，是一个空操作。 head落后于当前commit 如果 HEAD 和目标 commit 依然是不存在分叉，但 HEAD 不是领先于目标 commit，而是落后于目标 commit, Git 会直接把 HEAD（以及它所指向的 branch，如果有的话）移动到目标 commit。快速前移fast-forward 最流行的团队开发的工作流：Feature Branching这种工作流的核心包含以下两点： 任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； branch 写完后，合并到 master，然后删掉这个 branch。 命令行流程 1234567891011121314## 创建工作分支git checkout books## 分支代码完成后git push origin books## 同事review代码，合格后,mergegit checkout mastergit pullgit merge books## push代码git push## 删除工作分支git branch -d books## 如果有远程分支，也删除git push origin -d books 关于addadd把改动的内容放入暂存区 123## 全部暂存git add .## 每次修改或新增后需要重新add 看看我都干了些什么1234567891011121314## 了解修改时间，修改人，修改动作git log## 还需要看到修改细节git log -p## 查看修改统计git log --stat## 查看当前commit的内容git show## 比较暂存区和上一次提交git diff --staged## 比较工作目录和暂存区git diff## 比较工作目录和上一次提交git diff HEAD","tags":[{"name":"git","slug":"git","permalink":"https://flybids.github.io/tags/git/"}]},{"title":"CSS查漏补缺（二）","date":"2019-08-01T01:35:46.092Z","path":"2019/08/01/CSS查漏补缺（二）/","text":"CSS效果 效果属性 box-shadow 12box-shadow: 6px 6px 10px 10px rgba(1,2,3,4) 偏移量x,y+模糊区域z+扩展l+颜色c 外阴影box-shadow: inset x y z l color; 内阴影 阴影不会占位置，也就是不影响其他元素的布局。box-shadow后面可以跟多组值，从而有多个阴影。 营造立体感，层次感 充当没有宽度的边框 做一些特殊效果，如机器猫等 test-shadow text-shadow的值可以有多组，类似box-shadow 123.text&#123; text-shadow:1px 1px 1px #ddd; // 右下角(1,1) 模糊（1） 颜色（#ddd)&#125; 立体感 印刷的感觉 border-radius 圆角=》圆角矩形，原先，扇形，其他的图案 123456789.test&#123; border-radius:20%; // 值可以是百分数，具体的像素&#125;。test2&#123; border-top-left-radius:100px;&#125;.test3&#123; border-radius: 10px 10px 10px 10px / 20px 20px 20px 20px; // 水平和垂直方向&#125; background 纹理 图案 渐变 雪碧图动画 背景图尺寸适应 123background-position : center top;background-size: 200px 100px; // 或者百分比 或者cover 或者containbackground-repeat: repeat-x; clip-path 对容器显示进行裁剪，不影响占位 常见的几何图形 自定义路径进行裁剪 兼容性不好 123456789.div&#123; clip-path: inset(100px 50px) 方形 居中保留 // （100,100）的r =50 圆 cliP-path: circle(50px at 100px 100px) //多边形几个重要的节点连接 clip-path: polygon(50% 0,100% 50%,50% 100%, 0% 50%) // 使用svg clip-path:url(#clipath)&#125; 3D/2D 变换 ,不是动画 translate 位移 scale 缩放 skew 斜切 斜着拉扯 rotate 旋转 问题 一个div画出叮当猫： box-shadow无限投影+::before+::after 不占空间的边框 box-shadow outline 定制性不高 实现圆形 圆角矩形等 border-raius 实现ios图标的圆角 clip-path:(对应svg) 实现3d效果 123perspective: 500px; 透视角度transform-style: preserve-3d; 保留3d效果transform: translate rotate ...... CSS动画 动画给人以愉悦舒适的感觉，可以用来引起注意，对我们的操作进行反馈 questions css动画性能 性能不坏 部分情况下优于js js可以做到更好 部分属性兼容性差，如box-shadow 过渡动画和关键帧动画区别 过渡动画有状态变化 关键帧动画不需要状态变化 关键帧动画控制更精细 动画类型： transition补间动画 keyframe关键帧动画 逐帧动画（帧数从少到多） 补间动画 位置-平移 left/right/margin/transform 方位-旋转 transform 大小-缩放 transform 透明度 opacity 其他-线性变换(如宽度 高度等) transform 12transition : width 21s，height background 2s; //全部 all 10stransition-timing-function: linear // 动画进度和时间的关系,值有很多，也可以用贝塞尔曲线 关键帧动画 相当于多个补间动画，与元素状态的变化无关，定义更加灵活 123456789101112131415.test&#123; animation:run 1s; 或者 run 1s linear; animation-direction: reverse; // 反向 animation-iteration-count: infinite; // 次数，无限 animation-play-state: paused; //暂停 animation-fill-mode: forwards; //来回变&#125;@keyframes run&#123; 0%&#123; width :100px; &#125; 100%&#123; width: 1000px; &#125;&#125; 逐帧动画 没有自动补充帧的动画，关键帧动画的特殊用法之一（无法补帧,如多张图片在短时间内连续变换） 适用于无法补间计算的动画，资源较大，使用steps()，动画面积小，时间短 123456.test&#123; animation: run 1s linear; animation-iteration-count:infinite; animation-timing-function:steps(1); 关键帧之间有几个画面&#125;@keyframes run&#123;&#125; 预处理器基于css的另一种语言。可以借助工具编译成css,添加了很多css不具备的特性。它可以提升css文件的组织，如实现模块化等。主要包括两种，less , scss或者sass. less: 基于nodejs，编译快 scss: 基于ruby,编译慢 介绍 嵌套 反应层级和约束 变量 计算 减少重复代码 Extend Mixin 代码片段 循环 适用于复杂有规律的样式 import CSS文件模块化 嵌套 less 12345678910111213.wrapper&#123; background: red; .nav&#123; font-size:12px; &#125; .content&#123; font-size:21px; &amp;:hover&#123; // 平级 color: gray; &#125; &#125;&#125; scss 123456789101112.wraper&#123; background: white; .nav&#123; font-size:12px; &#125; .contend&#123; font-size:21px; &amp;hover&#123; backgroud: red; &#125; &#125;&#125; 变量 计算 减少重复代码 less 123456@fontSize: 12px;@bgColor: gray;.nav&#123; font-size: @fontSize + 10px; background: lighten(@bgColor, 40%)&#125; scss 123456$fontSize: 12px;$bgColor: gray;.nav&#123; font-size: $fontSize + 10px; background: lighten($bgColor,40%)&#125; mixin 对于共同代码，编译的css中是直接复制，重复率高，体积相对偏大 scss 123456789$fontSize: 12px;$bgColor: gray;@mixin block($fontSize)&#123; font-size: $fontSize; color: red;&#125;.nav&#123; @inclue block($fontSize+10px)&#125; less 123456789101112131415@fontSize: 12px;@bgColor: gray;.block(@fontSize,@bgColor)&#123; // 需要复用的代码 font-size: @fontSize + 10px; border: 10px solid red; background: lighten(@bgColor, 40%)&#125;.box&#123; color: blue;&#125;.nav&#123; .block(@fontSize+2px,@bgColor); .color();&#125; extend 编译的结果更小 less 123456789101112@fontSize: 12px;.block&#123; font-size:@fontSize; color: red;&#125;.wraper&#123; .nav:extend(.block)&#123; &amp;:hover&#123; color:yellow &#125; &#125;&#125; scss 1234567891011$fontSize: 12px;.block&#123; font-size:$fontSize; color: red;&#125;.box&#123; .nav&#123; @extend .block; &amp;:hover&#123; color: red; &#125; &#125;&#125; loop less 不支持循环，所以使用递归的方式实现 1234567.gen-col(@n) when (@n&gt;0) &#123; .gen-col(@n - 1); .col-@&#123;n&#125;&#123; width:1000px/12*@n; &#125;&#125;.gen-col(12); scss 支持循环 12345678910111213141516@mixin gen-col($n)&#123; @if $n&gt;0&#123; @include gen-col($n-1); .col-#&#123;$n&#125;&#123; width: 1000px/12*$n; &#125; &#125;&#125;@include gen-col(12) // 简单写法 @for $i from 1 through 12&#123; .col-#&#123;$i&#125;&#123; width: 1000px/12*$i; &#125;&#125; import less 12@import \"./1-import-variabel\"; //1@import \"./2-import-variable\"; //2 12// 1 定义变量的文件@fontSize: 20px; 123456// 2 模块文件.mdel&#123; .box&#123; font-size:@fontSize + 20px; &#125;&#125; scss 类似less 12@import \"./1-variabel\" @import \"./2-mdelss\" CSS预处理框架 SASS-Compass 处理兼容性等 Less-Lesshat/EST 12345@import \"est/all\" // 按需编译，用到的才会引入编译 .left&#123; float:left; .clearfix();&#125; 提供现成的mixin,类似JS类库 封装常用功能 其他","tags":[{"name":"css","slug":"css","permalink":"https://flybids.github.io/tags/css/"}]},{"title":"CSS查漏补缺（一）","date":"2019-08-01T01:35:46.091Z","path":"2019/08/01/CSS查漏补缺/","text":"CSS样式叠加问题 选择器的分类和权重计算 权重计算 ID选择器 +100 类 属性 伪类 +10 元素 伪元素 +1 其他 +0 需要注意的是，计算的时候不进位，权重低的不能通过数量来战胜权重高的 ！important最高 元素属性的优先级高 相同权重 后面写的会覆盖前面写的 分类： 类选择器.name{}， 元素选择器a{}， 伪元素选择器::before{}, 真实存在的元素,老旧的IE用单冒号 属性选择器[type=radio]{} 伪类选择器 :hover{} 某种状态下 ID选择器 组合选择器[type=checkbox]+label{} 否定选择器 :not(.link){} 通用选择器 *{} 浏览器对css的解析方式是从右到左，反过来的；这是出于对性能的考虑，更快的找到元素。 非布局样式 字相关 多字体 fallback,一个字体找不到，用下一个字体,针对的是每一个字符 使用网络字体， 自定义字体 (用于字体图标，宣传品牌banner等固定文案) 123456789@font-face&#123; font-family:\"IF\", src: url(\"地址\") // 可以本地，也可以远程&#125;.test&#123; font-family:IF;&#125;// 使用远程字体时，需要对应远程字体运行跨域// 远程也可以先用link引入，然后直接使用 iconfont 可以参考阿里矢量库 字体族：一堆的字体；不能加引号 衬线字体 宋体等 serif 非衬线字体 笔画起收规则的，如黑体 sans-serif 等宽字体 每个字符宽度相同 monospace 非等宽字体 手写体 cursive 花体 fantasy 1234.name&#123; font-family:\"PingFang SC\",serif;&#125;// serif 是字体族 PingFang SC是字体名称 背景和边框 边框 属性：线型 大小(solid dashed dotted) 颜色 1border: 1px solid blue; 边框背景图 12border: 30px solid transprant;border-image:url('../test.png') 30 round // 不常用 边框衔接 三角形 斜切 12border-bottom:30px solid red;border-right:30px solid blue; 背景 背景颜色 123456789101112test1&#123; background: red; // 少用&#125;test2&#123; background:rgb(1,2,3) // 不适合人眼，rgba透明度&#125;test3&#123; background:hsl(0,100%,50%) // 颜色 饱和度 亮度，适合人眼 hsla透明度&#125;test4&#123; background:url('../img/1.png')&#125; 渐变色背景css3,渐变可以当做图片背景，可以使用background-size属性等 1234567891011121314.c1&#123; background:linear-gradient(to right,red,green) // 左到右&#125;.c2&#123; background:linear-gradient(0deg,red,green) // 下到上， 45左下角到右下角&#125;.c3&#123; // 左到右,可以多个颜色 background:linear-gradient(to right,red 0,green 10%,yellow 100%) &#125;.c4&#123; // 叠加 background:linear-gradient(135deg,transparent 0,transparent 45%, red 45%, transparent 100%)，linear-gradient(135deg,transparent 0,transparent 45%, red 45%, transparent 100%)&#125; 多背景叠加css3 背景图片和属性 雪碧图 性能优化,减少http请求数，提高加载性能 123456&#123; background:red url('../q.png') // 图片平铺，改在颜色上面 // background-repeat(no-repeat,repeat-x等值） // background-position(center,top,20px等) , 坐标位置（相对于容器，取反数，一般负数） // background-size 缩小放大等等，缩小可以用来适配移动端好分辨率，比如分辨率三倍，就图片像素增加三倍，size缩小三倍&#125; base64 和性能优化 减少了http的请求 将图片转换为base64文本，使用javascript或工具进行转换；增大了解码的开销，体积增大三分之一，所以一般用于小图标，小图片。 项目中使用base64的时候，在打包的时候把图片转成base64 多分辨率适配 滚动 换行 文字折行 overflow-wrap 兼容性不好，一般写word-wrap，通用换行（是否保留单词） word-break 针对多字节文字（中文橘子也是单词） white-space 空白处是否换行 123456&#123; word-break: normal; // break-word 对单词可以换行 break-all 所有单词都可以换行 keep-all 所有单词都保留完整 overflow-wrap:normal; white-space:normal;&#125; 滚动： 内容比容器多 滚动行为 滚动条 (visible超出可见 hidden超出隐藏 scroll有滚动条 auto看情况滚动条) 1overflow:hidden; // 默认auto 粗体 斜体 下划线 这都是些装饰性属性。 font-weight:lighter normal=400 bold=700 bolder 100 (100到900，取x00,有兼容性)，一般normal或者bold, lighter bolder不同浏览器设备显示有差别 font-style: itatic 斜体 text-decoration cursor 其他 行高 line-height 行高的构成: 一行的最大行高可以撑起外层盒子的高度（line-box包含inline-box)，可以基于这个实现垂直居中。 行高相关的现象和方案： 行内元素默认baseline对齐；在设置对齐方式时，每个行内元素都要设置vertical-align,vertical-align也可以使用数字（此时是相对于baseline的位置）； 布局 layout 简介 早期以table为主，但是用户等待时间更长，语义不明确；后期以技巧性地布局为主（本来不是用来布局的东西） 现在有flexbox， grid, 响应式布局 常见布局方法： table, float+margin, inline-block,flexbox 盒模型 content padding border margin (height,width指content) display(block,inline,inline-block) position(static, absolute脱离文档流,fixed脱离文档流,relative,sticky新的属性,还有inherit) z-index只对定位元素有效，什么是定位元素呢？说简单点就是设置了position属性的元素，position的属性值如下：absolute-绝对定位、relative-相对定位、fixed-固定定位、inherit-继承父元素定位，static-静态定位。这里要注意，并不是所有的定位设置都有效果，absolute、relative和fixed是肯定有效果的，inherit取决于父元素，如果父元素没有设置定位则z-index无效，注意低版本IE浏览器不支持这个值。最后说下static这个静态定位，其实这是默认值，表示当前元素不进行定位，所以如果元素设置了这个属性值，其实是和没有设置是一样的，会使元素忽略掉z-index属性，使其不起作用。 盒模型 content padding border margin (height,width指content) flexbox 弹性盒子 盒子本来就是并列的，指定宽度就可 12345678910.item0&#123; flex:1; 占据box的一份 &#125;.itm1&#123; flex: none; width:70px; 占70px宽带&#125;.box&#123; display:flex;&#125; flexbox还有其他的属性,由于兼容性的问题，还没有被大规模使用，移动端兼容性更好 float布局 元素浮动，脱离文档流（不对其他元素布局起作用），但是不脱离文本流（会排挤其他元素的文本） 形成块（BFC),宽和高自己定，位置尽量（上，左（右）） 相当于从父级消失，可能导致父级的高度塌陷 可以使用伪元素清楚浮动 1234567cls::after&#123; display:block; content:''; visibity: hidden; height:0; clear:both;&#125; 问题：float + margin 三栏布局 inline-block 布局 像文本一样排block元素，但是需要处理间隙问题 解决间隙问题：父元素字体大小设为0，里面的字体再设回来；或者再代码里面，两个inline-block之间没有空格，或者加上注释占用空格 1234567891011test1&#123; font-size :0; .child1&#123; font-size:14px; display:inline-block; &#125; .child2&#123; font-size:13px; display:inline-block; &#125;&#125; 12345&lt;div style=\"display:inline-block;\"&gt; 123&lt;/div&gt;&lt;div style=\"display:inline-block\"&gt; 456&lt;/div&gt; 响应式布局 再不同设备上正常使用，一般针对屏幕大小。主要的方法包括： 隐藏一些东西 + 折行 + 留下自适应空间 rem, viewport , media query 1234567891011&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;...&lt;meta name=\"viewport\" content=\"width=320\"&gt;....&lt;style&gt; @media (max-width:640px)&#123; .left&#123; display:none; &#125; &#125;&lt;/style&gt; 12 table 布局 直接用表格 仿照表格的样式 12display: table-cell;display: table-row; CSS Hack 兼容浏览器，不合法但是生效的写法，难理解，难维护，容易失效，hack属性要写在正常属性后面 1234.test&#123; width:200px; width:100px\\9;&#125; 替代方案：特性检测，针对性加class,更推荐 如何优化checkbox label[for] 和 id 隐藏元素input :checked + label 12","tags":[{"name":"css","slug":"css","permalink":"https://flybids.github.io/tags/css/"}]}]